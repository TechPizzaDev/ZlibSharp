// Generated by Sichem at 2020-09-30 18:30:54

using System.Runtime.InteropServices;

namespace ZlibSharp
{
    internal unsafe class InfTrees
    {
        public const int CODES = 0;
        public const int LENS = 1;
        public const int DISTS = 2;
        public static sbyte*[] z_errmsg = new sbyte[10];
        public static sbyte[] inflate_copyright = " inflate 1.2.11 Copyright 1995-2017 Mark Adler ";
        [StructLayout(LayoutKind.Sequential)]
        public class z_stream_s
        {
            public byte* next_in;
            public uint avail_in;
            public int total_in;
            public byte* next_out;
            public uint avail_out;
            public int total_out;
            public string msg;
            public internal_state state;
            public zalloc_delegate zalloc;
            public zfree_delegate zfree;
            public void* opaque;
            public int data_type;
            public int adler;
            public int reserved;
        }
        [StructLayout(LayoutKind.Sequential)]
        public struct gz_header_s
        {
            public int text;
            public int time;
            public int xflags;
            public int os;
            public byte* extra;
            public uint extra_len;
            public uint extra_max;
            public byte* name;
            public uint name_max;
            public byte* comment;
            public uint comm_max;
            public int hcrc;
            public int done;
        }
        [StructLayout(LayoutKind.Sequential)]
        public struct gzFile_s
        {
            public uint have;
            public byte* next;
            public long pos;
        }
        [StructLayout(LayoutKind.Sequential)]
        public struct code
        {
            public byte op;
            public byte bits;
            public ushort val;
        }
        public static int inflate_table(int type, ushort* lens, uint codes, code** table, uint* bits, ushort* work)
        {
            uint len = 0;
            uint sym = 0;
            uint min = 0;
            uint max = 0;
            uint root = 0;
            uint curr = 0;
            uint drop = 0;
            int left = 0;
            uint used = 0;
            uint huff = 0;
            uint incr = 0;
            uint fill = 0;
            uint low = 0;
            uint mask = 0;
            code here = new code();
            code* next;
            ushort* _base_;
            ushort* extra;
            uint match = 0;
            ushort* count = stackalloc ushort[15 + 1];
            ushort* offs = stackalloc ushort[15 + 1];
            ushort* lbase = stackalloc ushort[31];
            lbase[0] = 3;
            lbase[1] = 4;
            lbase[2] = 5;
            lbase[3] = 6;
            lbase[4] = 7;
            lbase[5] = 8;
            lbase[6] = 9;
            lbase[7] = 10;
            lbase[8] = 11;
            lbase[9] = 13;
            lbase[10] = 15;
            lbase[11] = 17;
            lbase[12] = 19;
            lbase[13] = 23;
            lbase[14] = 27;
            lbase[15] = 31;
            lbase[16] = 35;
            lbase[17] = 43;
            lbase[18] = 51;
            lbase[19] = 59;
            lbase[20] = 67;
            lbase[21] = 83;
            lbase[22] = 99;
            lbase[23] = 115;
            lbase[24] = 131;
            lbase[25] = 163;
            lbase[26] = 195;
            lbase[27] = 227;
            lbase[28] = 258;
            lbase[29] = 0;
            lbase[30] = 0;

            ushort* lext = stackalloc ushort[31];
            lext[0] = 16;
            lext[1] = 16;
            lext[2] = 16;
            lext[3] = 16;
            lext[4] = 16;
            lext[5] = 16;
            lext[6] = 16;
            lext[7] = 16;
            lext[8] = 17;
            lext[9] = 17;
            lext[10] = 17;
            lext[11] = 17;
            lext[12] = 18;
            lext[13] = 18;
            lext[14] = 18;
            lext[15] = 18;
            lext[16] = 19;
            lext[17] = 19;
            lext[18] = 19;
            lext[19] = 19;
            lext[20] = 20;
            lext[21] = 20;
            lext[22] = 20;
            lext[23] = 20;
            lext[24] = 21;
            lext[25] = 21;
            lext[26] = 21;
            lext[27] = 21;
            lext[28] = 16;
            lext[29] = 77;
            lext[30] = 202;

            ushort* dbase = stackalloc ushort[32];
            dbase[0] = 1;
            dbase[1] = 2;
            dbase[2] = 3;
            dbase[3] = 4;
            dbase[4] = 5;
            dbase[5] = 7;
            dbase[6] = 9;
            dbase[7] = 13;
            dbase[8] = 17;
            dbase[9] = 25;
            dbase[10] = 33;
            dbase[11] = 49;
            dbase[12] = 65;
            dbase[13] = 97;
            dbase[14] = 129;
            dbase[15] = 193;
            dbase[16] = 257;
            dbase[17] = 385;
            dbase[18] = 513;
            dbase[19] = 769;
            dbase[20] = 1025;
            dbase[21] = 1537;
            dbase[22] = 2049;
            dbase[23] = 3073;
            dbase[24] = 4097;
            dbase[25] = 6145;
            dbase[26] = 8193;
            dbase[27] = 12289;
            dbase[28] = 16385;
            dbase[29] = 24577;
            dbase[30] = 0;
            dbase[31] = 0;

            ushort* dext = stackalloc ushort[32];
            dext[0] = 16;
            dext[1] = 16;
            dext[2] = 16;
            dext[3] = 16;
            dext[4] = 17;
            dext[5] = 17;
            dext[6] = 18;
            dext[7] = 18;
            dext[8] = 19;
            dext[9] = 19;
            dext[10] = 20;
            dext[11] = 20;
            dext[12] = 21;
            dext[13] = 21;
            dext[14] = 22;
            dext[15] = 22;
            dext[16] = 23;
            dext[17] = 23;
            dext[18] = 24;
            dext[19] = 24;
            dext[20] = 25;
            dext[21] = 25;
            dext[22] = 26;
            dext[23] = 26;
            dext[24] = 27;
            dext[25] = 27;
            dext[26] = 28;
            dext[27] = 28;
            dext[28] = 29;
            dext[29] = 29;
            dext[30] = 64;
            dext[31] = 64;

            for (len = 0; len <= 15; len++)
            { count[len] = 0; }
            for (sym = 0; sym < codes; sym++)
            { count[lens[sym]]++; }
            root = *bits;
            for (max = 15; max >= 1; max--)
            { if (count[max] != 0) break; }
            if (root > max)
                root = max;
            if (max == 0)
            {
                here.op = 64;
                here.bits = 1;
                here.val = 0;
                *(*table)++ = here;
                *(*table)++ = here;
                *bits = 1;
                return 0;
            }

            for (min = 1; min < max; min++)
            { if (count[min] != 0) break; }
            if (root < min)
                root = min;
            left = 1;
            for (len = 1; len <= 15; len++)
            {
                left <<= 1;
                left -= count[len];
                if (left < 0)
                    return -1;
            }
            if ((left > 0) && ((type == CODES) || (max != 1)))
                return -1;
            offs[1] = 0;
            for (len = 1; len < 15; len++)
            { offs[len + 1] = (ushort)(offs[len] + count[len]); }
            for (sym = 0; sym < codes; sym++)
            { if (lens[sym] != 0) work[offs[lens[sym]]++] = (ushort)sym; }
            switch (type)
            {
                case CODES:
                    _base_ = extra = work;
                    match = 20;
                    break;
                case LENS:
                    _base_ = lbase;
                    extra = lext;
                    match = 257;
                    break;
                default:
                    _base_ = dbase;
                    extra = dext;
                    match = 0;
            }

            huff = 0;
            sym = 0;
            len = min;
            next = *table;
            curr = root;
            drop = 0;
            low = (uint)-1;
            used = (uint)(1U << root);
            mask = used - 1;
            if (((type == LENS) && (used > 852)) || ((type == DISTS) && (used > 592)))
                return 1;
            for (; ; )
            {
                here.bits = (byte)(len - drop);
                if ((work[sym] + 1U) < match)
                {
                    here.op = 0;
                    here.val = work[sym];
                }
                else if (work[sym] >= match)
                {
                    here.op = (byte)extra[work[sym] - match];
                    here.val = _base_[work[sym] - match];
                }
                else
                {
                    here.op = 32 + 64;
                    here.val = 0;
                }
                incr = (uint)(1U << (len - drop));
                fill = (uint)(1U << curr);
                min = fill;
                do
                {
                    fill -= incr;
                    next[(huff >> drop) + fill] = here;
                }
                while (fill != 0);
                incr = (uint)(1U << (len - 1));
                while ((huff & incr) != 0)
                { incr >>= 1; }
                if (incr != 0)
                {
                    huff &= incr - 1;
                    huff += incr;
                }
                else
                    huff = 0;
                sym++;
                if ((--count[len]) == 0)
                {
                    if (len == max)
                        break;
                    len = lens[work[sym]];
                }
                if ((len > root) && ((huff & mask) != low))
                {
                    if (drop == 0)
                        drop = root;
                    next += min;
                    curr = len - drop;
                    left = (int)(1 << curr);
                    while ((curr + drop) < max)
                    {
                        left -= count[curr + drop];
                        if (left <= 0)
                            break;
                        curr++;
                        left <<= 1;
                    }
                    used += (uint)(1U << curr);
                    if (((type == LENS) && (used > 852)) || ((type == DISTS) && (used > 592)))
                        return 1;
                    low = huff & mask;
                    (*table)[low].op = (byte)curr;
                    (*table)[low].bits = (byte)root;
                    (*table)[low].val = (ushort)(next - *table);
                }
            }
            if (huff != 0)
            {
                here.op = 64;
                here.bits = (byte)(len - drop);
                here.val = 0;
                next[huff] = here;
            }

            *table += used;
            *bits = root;
            return 0;
        }

    }
}