// Generated by Sichem at 2020-09-30 18:30:54

using System;
using System.Runtime.InteropServices;
using static CRuntime;

namespace ZlibSharp
{
	unsafe class InfTrees
	{
		public const int CODES = 0;
		public const int LENS = 1;
		public const int DISTS = 2;
		public static sbyte*[] z_errmsg = new sbyte[10];
		public static sbyte[] inflate_copyright = " inflate 1.2.11 Copyright 1995-2017 Mark Adler ";
		[StructLayout(LayoutKind.Sequential)]
		public class z_stream_s
	{
		public byte* next_in;
		public uint avail_in;
		public int total_in;
		public byte* next_out;
		public uint avail_out;
		public int total_out;
		public string msg;
		public internal_state state;
		public zalloc_delegate zalloc;
		public zfree_delegate zfree;
		public void * opaque;
		public int data_type;
		public int adler;
		public int reserved;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct gz_header_s
	{
		public int text;
		public int time;
		public int xflags;
		public int os;
		public byte* extra;
		public uint extra_len;
		public uint extra_max;
		public byte* name;
		public uint name_max;
		public byte* comment;
		public uint comm_max;
		public int hcrc;
		public int done;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct gzFile_s
	{
		public uint have;
		public byte* next;
		public long pos;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct code
	{
		public byte op;
		public byte bits;
		public ushort val;
		}
		public static int inflate_table(int type, ushort* lens, uint codes, code** table, uint* bits, ushort* work)
		{
			uint len = 0;
			uint sym = 0;
			uint min = 0;uint max = 0;
			uint root = 0;
			uint curr = 0;
			uint drop = 0;
			int left = 0;
			uint used = 0;
			uint huff = 0;
			uint incr = 0;
			uint fill = 0;
			uint low = 0;
			uint mask = 0;
			code here = new code();
			code* next;
			ushort* _base_;
			ushort* extra;
			uint match = 0;
			ushort* count = stackalloc ushort[15 + 1];
			ushort* offs = stackalloc ushort[15 + 1];
			ushort* lbase = stackalloc ushort[31];
lbase[0] = (ushort)(3);
lbase[1] = (ushort)(4);
lbase[2] = (ushort)(5);
lbase[3] = (ushort)(6);
lbase[4] = (ushort)(7);
lbase[5] = (ushort)(8);
lbase[6] = (ushort)(9);
lbase[7] = (ushort)(10);
lbase[8] = (ushort)(11);
lbase[9] = (ushort)(13);
lbase[10] = (ushort)(15);
lbase[11] = (ushort)(17);
lbase[12] = (ushort)(19);
lbase[13] = (ushort)(23);
lbase[14] = (ushort)(27);
lbase[15] = (ushort)(31);
lbase[16] = (ushort)(35);
lbase[17] = (ushort)(43);
lbase[18] = (ushort)(51);
lbase[19] = (ushort)(59);
lbase[20] = (ushort)(67);
lbase[21] = (ushort)(83);
lbase[22] = (ushort)(99);
lbase[23] = (ushort)(115);
lbase[24] = (ushort)(131);
lbase[25] = (ushort)(163);
lbase[26] = (ushort)(195);
lbase[27] = (ushort)(227);
lbase[28] = (ushort)(258);
lbase[29] = (ushort)(0);
lbase[30] = (ushort)(0);

			ushort* lext = stackalloc ushort[31];
lext[0] = (ushort)(16);
lext[1] = (ushort)(16);
lext[2] = (ushort)(16);
lext[3] = (ushort)(16);
lext[4] = (ushort)(16);
lext[5] = (ushort)(16);
lext[6] = (ushort)(16);
lext[7] = (ushort)(16);
lext[8] = (ushort)(17);
lext[9] = (ushort)(17);
lext[10] = (ushort)(17);
lext[11] = (ushort)(17);
lext[12] = (ushort)(18);
lext[13] = (ushort)(18);
lext[14] = (ushort)(18);
lext[15] = (ushort)(18);
lext[16] = (ushort)(19);
lext[17] = (ushort)(19);
lext[18] = (ushort)(19);
lext[19] = (ushort)(19);
lext[20] = (ushort)(20);
lext[21] = (ushort)(20);
lext[22] = (ushort)(20);
lext[23] = (ushort)(20);
lext[24] = (ushort)(21);
lext[25] = (ushort)(21);
lext[26] = (ushort)(21);
lext[27] = (ushort)(21);
lext[28] = (ushort)(16);
lext[29] = (ushort)(77);
lext[30] = (ushort)(202);

			ushort* dbase = stackalloc ushort[32];
dbase[0] = (ushort)(1);
dbase[1] = (ushort)(2);
dbase[2] = (ushort)(3);
dbase[3] = (ushort)(4);
dbase[4] = (ushort)(5);
dbase[5] = (ushort)(7);
dbase[6] = (ushort)(9);
dbase[7] = (ushort)(13);
dbase[8] = (ushort)(17);
dbase[9] = (ushort)(25);
dbase[10] = (ushort)(33);
dbase[11] = (ushort)(49);
dbase[12] = (ushort)(65);
dbase[13] = (ushort)(97);
dbase[14] = (ushort)(129);
dbase[15] = (ushort)(193);
dbase[16] = (ushort)(257);
dbase[17] = (ushort)(385);
dbase[18] = (ushort)(513);
dbase[19] = (ushort)(769);
dbase[20] = (ushort)(1025);
dbase[21] = (ushort)(1537);
dbase[22] = (ushort)(2049);
dbase[23] = (ushort)(3073);
dbase[24] = (ushort)(4097);
dbase[25] = (ushort)(6145);
dbase[26] = (ushort)(8193);
dbase[27] = (ushort)(12289);
dbase[28] = (ushort)(16385);
dbase[29] = (ushort)(24577);
dbase[30] = (ushort)(0);
dbase[31] = (ushort)(0);

			ushort* dext = stackalloc ushort[32];
dext[0] = (ushort)(16);
dext[1] = (ushort)(16);
dext[2] = (ushort)(16);
dext[3] = (ushort)(16);
dext[4] = (ushort)(17);
dext[5] = (ushort)(17);
dext[6] = (ushort)(18);
dext[7] = (ushort)(18);
dext[8] = (ushort)(19);
dext[9] = (ushort)(19);
dext[10] = (ushort)(20);
dext[11] = (ushort)(20);
dext[12] = (ushort)(21);
dext[13] = (ushort)(21);
dext[14] = (ushort)(22);
dext[15] = (ushort)(22);
dext[16] = (ushort)(23);
dext[17] = (ushort)(23);
dext[18] = (ushort)(24);
dext[19] = (ushort)(24);
dext[20] = (ushort)(25);
dext[21] = (ushort)(25);
dext[22] = (ushort)(26);
dext[23] = (ushort)(26);
dext[24] = (ushort)(27);
dext[25] = (ushort)(27);
dext[26] = (ushort)(28);
dext[27] = (ushort)(28);
dext[28] = (ushort)(29);
dext[29] = (ushort)(29);
dext[30] = (ushort)(64);
dext[31] = (ushort)(64);

			for (len = (uint)(0); len <= 15; len++) {count[len] = (ushort)(0);}
			for (sym = (uint)(0); (sym) < (codes); sym++) {count[lens[sym]]++;}
			root = (uint)(*bits);
			for (max = (uint)(15); (max) >= (1); max--) {if (count[max] != 0) break;}
			if ((root) > (max)) root = (uint)(max);
			if ((max) == (0)) {
here.op = ((byte)(64));here.bits = ((byte)(1));here.val = ((ushort)(0));*(*table)++ = (code)(here);*(*table)++ = (code)(here);*bits = (uint)(1);return (int)(0);}

			for (min = (uint)(1); (min) < (max); min++) {if (count[min] != 0) break;}
			if ((root) < (min)) root = (uint)(min);
			left = (int)(1);
			for (len = (uint)(1); len <= 15; len++) {
left <<= 1;left -= (int)(count[len]);if ((left) < (0)) return (int)(-1);}
			if (((left) > (0)) && (((type) == (CODES)) || (max != 1))) return (int)(-1);
			offs[1] = (ushort)(0);
			for (len = (uint)(1); (len) < (15); len++) {offs[len + 1] = (ushort)(offs[len] + count[len]);}
			for (sym = (uint)(0); (sym) < (codes); sym++) {if (lens[sym] != 0) work[offs[lens[sym]]++] = ((ushort)(sym));}
			switch (type){
case CODES:_base_ = extra = work;match = (uint)(20);break;case LENS:_base_ = lbase;extra = lext;match = (uint)(257);break;default: _base_ = dbase;extra = dext;match = (uint)(0);}

			huff = (uint)(0);
			sym = (uint)(0);
			len = (uint)(min);
			next = *table;
			curr = (uint)(root);
			drop = (uint)(0);
			low = ((uint)(-1));
			used = (uint)(1U << root);
			mask = (uint)(used - 1);
			if ((((type) == (LENS)) && ((used) > (852))) || (((type) == (DISTS)) && ((used) > (592)))) return (int)(1);
			for (; ; ) {
here.bits = ((byte)(len - drop));if ((work[sym] + 1U) < (match)) {
here.op = ((byte)(0));here.val = (ushort)(work[sym]);}
 else if ((work[sym]) >= (match)) {
here.op = ((byte)(extra[work[sym] - match]));here.val = (ushort)(_base_[work[sym] - match]);}
 else {
here.op = ((byte)(32 + 64));here.val = (ushort)(0);}
incr = (uint)(1U << (len - drop));fill = (uint)(1U << curr);min = (uint)(fill);do {
fill -= (uint)(incr);next[(huff >> drop) + fill] = (code)(here);}
 while (fill != 0);incr = (uint)(1U << (len - 1));while ((huff & incr) != 0) {incr >>= 1;}if (incr != 0) {
huff &= (uint)(incr - 1);huff += (uint)(incr);}
 else huff = (uint)(0);sym++;if ((--(count[len])) == (0)) {
if ((len) == (max)) break;len = (uint)(lens[work[sym]]);}
if (((len) > (root)) && ((huff & mask) != low)) {
if ((drop) == (0)) drop = (uint)(root);next += min;curr = (uint)(len - drop);left = (int)(1 << curr);while ((curr + drop) < (max)) {
left -= (int)(count[curr + drop]);if (left <= 0) break;curr++;left <<= 1;}used += (uint)(1U << curr);if ((((type) == (LENS)) && ((used) > (852))) || (((type) == (DISTS)) && ((used) > (592)))) return (int)(1);low = (uint)(huff & mask);(*table)[low].op = ((byte)(curr));(*table)[low].bits = ((byte)(root));(*table)[low].val = ((ushort)(next - *table));}
}
			if (huff != 0) {
here.op = ((byte)(64));here.bits = ((byte)(len - drop));here.val = ((ushort)(0));next[huff] = (code)(here);}

			*table += used;
			*bits = (uint)(root);
			return (int)(0);
		}

}
}