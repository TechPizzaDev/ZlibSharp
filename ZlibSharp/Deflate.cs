// Generated by Sichem at 2020-09-30 18:30:50

using System;
using System.Runtime.InteropServices;
using static CRuntime;
using static ZlibSharp.ZUtil;
using static ZlibSharp.Adler32;
using static ZlibSharp.Crc32;
using static ZlibSharp.Trees;
using System.Runtime.CompilerServices;

namespace ZlibSharp
{
    public unsafe class Deflate
    {
        /* number of length codes, not counting the special END_BLOCK code */
        public const int LENGTH_CODES = 29;

        /* number of literal bytes 0..255 */
        public const int LITERALS = 256;

        /* number of Literal or Length codes, including the END_BLOCK code */
        public const int L_CODES = LITERALS + 1 + LENGTH_CODES;

        /* number of distance codes */
        public const int D_CODES = 30;

        /* number of codes used to transfer the bit lengths */
        public const int BL_CODES = 19;

        /* maximum heap size */
        public const int HEAP_SIZE = 2 * L_CODES + 1;

        /* All codes must not exceed MAX_BITS bits */
        public const int MAX_BITS = 15;

        public const int MIN_MATCH = 3;
        public const int MAX_MATCH = 258;

        public const int need_more = 0;
        public const int block_done = 1;
        public const int finish_started = 2;
        public const int finish_done = 3;
        public static string[] z_errmsg = new string[10];

        public static string deflate_copyright = " deflate 1.2.11 Copyright 1995-2017 Jean-loup Gailly and Mark Adler ";

        public static config_s[] configuration_table = new[]
        {
            new config_s(0, 0, 0, 0, deflate_stored),
            new config_s(4, 4, 8, 4, deflate_fast),
            new config_s( 4, 5, 16, 8, deflate_fast),
            new config_s(4, 6, 32, 32, deflate_fast),
            new config_s(4, 4, 16, 16, deflate_slow),
            new config_s(8, 16, 32, 32, deflate_slow),
            new config_s(8, 16, 128, 128, deflate_slow),
            new config_s(8, 32, 128, 256, deflate_slow),
            new config_s(32, 128, 258, 1024, deflate_slow),
            new config_s(32, 258, 258, 4096, deflate_slow)
        };

        public const int DIST_CODE_LEN = 512;

        private static byte[] _dist_code = new byte[DIST_CODE_LEN] {
             0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,
             8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
            10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
            11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
            12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13,
            13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
            13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
            14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
            14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
            14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
            15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
            15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
            15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  0,  0, 16, 17,
            18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
            23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
            24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
            26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
            26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,
            27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
            27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
            28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
            28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
            28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
            29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
            29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
            29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
        };

        private static byte[] _length_code = new byte[MAX_MATCH - MIN_MATCH + 1] {
             0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 12, 12,
            13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
            17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19,
            19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
            21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22,
            22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,
            23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
            24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
            25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
            25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
            26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
            26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
            27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28
        };

        [StructLayout(LayoutKind.Sequential)]
        public struct config_s
        {
            public ushort good_length;
            public ushort max_lazy;
            public ushort nice_length;
            public ushort max_chain;
            public deflate_func func;

            public config_s(ushort good_length, ushort max_lazy, ushort nice_length, ushort max_chain, deflate_func func)
            {
                this.good_length = good_length;
                this.max_lazy = max_lazy;
                this.nice_length = nice_length;
                this.max_chain = max_chain;
                this.func = func ?? throw new ArgumentNullException(nameof(func));
            }
        }
        public static void slide_hash(internal_state s)
        {
            uint m = 0;
            int n = s.hash_size;
            ref ushort p = ref s.head[n];
            int wsize = s.w_size;
            do
            {
                m = --p;
                p = (ushort)(m >= wsize ? m - wsize : 0);
            }
            while ((--n) != 0);

            n = wsize;
            p = ref s.prev[n];
            do
            {
                m = --p;
                p = (ushort)(m >= wsize ? m - wsize : 0);
            }
            while ((--n) != 0);
        }

        public static int deflateInit_(z_stream_s strm, int level, string version)
        {
            return deflateInit2_(strm, level, 8, 15, 8, 0, version);
        }

        public static int deflateInit2_(
            z_stream_s strm, int level, int method, int windowBits, int memLevel, int strategy, string version)
        {
            int wrap = 1;
            string my_version = "1.2.11";
            if ((version == null) || (version[0] != my_version[0]))
            {
                return -6;
            }

            if (strm == null)
                return -2;
            strm.msg = null;

            if (level == (-1))
                level = 6;
            if (windowBits < 0)
            {
                wrap = 0;
                windowBits = -windowBits;
            }
            else if (windowBits > 15)
            {
                wrap = 2;
                windowBits -= 16;
            }

            if ((memLevel < 1) || (memLevel > 9) || (method != 8) || (windowBits < 8) || (windowBits > 15) || (level < 0) || (level > 9) || (strategy < 0) || (strategy > 4) || ((windowBits == 8) && (wrap != 1)))
            {
                return -2;
            }

            if (windowBits == 8)
                windowBits = 9;

            var s = new internal_state();
            strm.state = s;
            s.strm = strm;
            s.status = 42;
            s.wrap = wrap;
            s.gzhead = null;
            s.w_bits = windowBits;
            s.w_size = 1 << s.w_bits;
            s.w_mask = s.w_size - 1;
            s.hash_bits = memLevel + 7;
            s.hash_size = 1 << s.hash_bits;
            s.hash_mask = (uint)(s.hash_size - 1);
            s.hash_shift = (s.hash_bits + 3 - 1) / 3;
            s.window = new byte[s.w_size * 2];
            s.prev = new ushort[s.w_size];
            s.head = new ushort[s.hash_size];
            s.high_water = 0;
            s.lit_bufsize = 1 << (memLevel + 6);
            s.pending_buf = new byte[s.lit_bufsize * 4];
            if ((s.window == null) || (s.prev == null) || (s.head == null) || (s.pending_buf == null))
            {
                s.status = 666;
                strm.msg = z_errmsg[2 - (-4)];
                deflateEnd(strm);
                return -4;
            }

            s.d_buf = s.pending_buf[(s.lit_bufsize / 2)..(s.lit_bufsize * 3)];
            s.l_buf = s.pending_buf[(s.lit_bufsize * 3)..];
            s.level = level;
            s.strategy = strategy;
            s.method = (byte)method;
            return deflateReset(strm);
        }

        public static int deflateStateCheck(z_stream_s strm)
        {
            if ((strm == null))
                return 1;
            internal_state s = strm.state;
            if ((s == null) || (s.strm != strm) || ((s.status != 42) && (s.status != 57) && (s.status != 69) && (s.status != 73) && (s.status != 91) && (s.status != 103) && (s.status != 113) && (s.status != 666)))
                return 1;
            return 0;
        }

        public static int deflateSetDictionary(z_stream_s strm, ReadOnlySpan<byte> dictionary)
        {
            if ((deflateStateCheck(strm) != 0) || (dictionary == null))
                return -2;
            internal_state s = strm.state;
            int wrap = s.wrap;
            if ((wrap == 2) || ((wrap == 1) && (s.status != 42)) || (s.lookahead != 0))
                return -2;
            if (wrap == 1)
                strm.checksum = adler32(strm.checksum, dictionary);
            s.wrap = 0;
            if (dictionary.Length >= s.w_size)
            {
                if (wrap == 0)
                {
                    s.head.AsSpan().Clear();
                    s.strstart = 0;
                    s.block_start = 0;
                    s.insert = 0;
                }
                dictionary = dictionary.Slice(dictionary.Length - s.w_size, s.w_size);
            }

            int avail = strm.avail_in;
            var next = strm.next_in;
            var next_off = strm.next_in_off;
            strm.avail_in = dictionary.Length;
            strm.next_in = dictionary.ToArray(); // TODO: make into Span
            strm.next_in_off = 0;
            fill_window(s);
            while (s.lookahead >= 3)
            {
                int str = s.strstart;
                int n = s.lookahead - (3 - 1);
                do
                {
                    s.ins_h = (((s.ins_h) << s.hash_shift) ^ (s.window[str + 3 - 1])) & s.hash_mask;
                    s.prev[str & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = (ushort)str;
                    str++;
                }
                while ((--n) != 0);
                s.strstart = str;
                s.lookahead = 3 - 1;
                fill_window(s);
            }
            s.strstart += s.lookahead;
            s.block_start = s.strstart;
            s.insert = s.lookahead;
            s.lookahead = 0;
            s.match_length = s.prev_length = 3 - 1;
            s.match_available = 0;
            strm.next_in = next;
            strm.next_in_off = next_off;
            strm.avail_in = avail;
            s.wrap = wrap;
            return 0;
        }

        public static int deflateGetDictionary(z_stream_s strm, Span<byte> dictionary, out int dictLength)
        {
            if (deflateStateCheck(strm) != 0)
            {
                dictLength = default;
                return -2;
            }

            internal_state s = strm.state;
            int len = s.strstart + s.lookahead;
            if (len > s.w_size)
                len = s.w_size;

            if (len != 0)
                s.window.AsSpan(s.strstart + s.lookahead - len, len).CopyTo(dictionary);

            dictLength = len;
            return 0;
        }

        public static int deflateResetKeep(z_stream_s strm)
        {
            if (deflateStateCheck(strm) != 0)
            {
                return -2;
            }

            strm.total_in = strm.total_out = 0;
            strm.msg = null;
            strm.data_type = 2;
            internal_state s = strm.state;
            s.pending = 0;
            s.pending_out = s.pending_buf;
            if (s.wrap < 0)
            {
                s.wrap = -s.wrap;
            }

            s.status = s.wrap == 2 ? 57 : s.wrap != 0 ? 42 : 113;
            strm.checksum = s.wrap == 2 ? crc32(0, default) : adler32(0, default);
            s.last_flush = 0;
            _tr_init(s);
            return 0;
        }

        public static int deflateReset(z_stream_s strm)
        {
            int ret = deflateResetKeep(strm);
            if (ret == 0)
                lm_init(strm.state);
            return ret;
        }

        public static int deflateSetHeader(z_stream_s strm, gz_header_s head)
        {
            if ((deflateStateCheck(strm) != 0) || (strm.state.wrap != 2))
                return -2;
            strm.state.gzhead = head;
            return 0;
        }

        public static int deflatePending(z_stream_s strm, uint* pending, int* bits)
        {
            if (deflateStateCheck(strm) != 0)
                return -2;
            if (pending != null)
                *pending = (uint)strm.state.pending;
            if (bits != null)
                *bits = strm.state.bi_valid;
            return 0;
        }

        public const int Buf_size = 16;

        public static int deflatePrime(z_stream_s strm, int bits, int value)
        {
            if (deflateStateCheck(strm) != 0)
                return -2;

            internal_state s = strm.state;
            if (Unsafe.IsAddressLessThan(
                ref s.d_buf.Span[0],
                ref Unsafe.Add(ref s.pending_out.Span[0], (Buf_size + 7) >> 3)))
                return -5;

            do
            {
                int put = Buf_size - s.bi_valid;
                if (put > bits)
                    put = bits;
                s.bi_buf |= (ushort)((value & ((1 << put) - 1)) << s.bi_valid);
                s.bi_valid += put;
                _tr_flush_bits(s);
                value >>= put;
                bits -= put;
            }
            while (bits != 0);
            return 0;
        }

        public static int deflateParams(z_stream_s strm, int level, int strategy)
        {
            if (deflateStateCheck(strm) != 0)
                return -2;

            internal_state s = strm.state;
            if (level == (-1))
                level = 6;
            if ((level < 0) || (level > 9) || (strategy < 0) || (strategy > 4))
            {
                return -2;
            }

            deflate_func func = configuration_table[s.level].func;
            if (((strategy != s.strategy) || (func != configuration_table[level].func)) && (s.high_water != 0))
            {
                int err = deflate(strm, 5);
                if (err == (-2))
                    return err;
                if (strm.avail_out == 0)
                    return -5;
            }

            if (s.level != level)
            {
                if ((s.level == 0) && (s.matches != 0))
                {
                    if (s.matches == 1)
                        slide_hash(s);
                    else
                        s.head[s.hash_size - 1] = 0;
                    s.head.AsSpan()[0..^1].Clear();
                    s.matches = 0;
                }
                s.level = level;
                s.max_lazy_match = configuration_table[level].max_lazy;
                s.good_match = configuration_table[level].good_length;
                s.nice_match = configuration_table[level].nice_length;
                s.max_chain_length = configuration_table[level].max_chain;
            }

            s.strategy = strategy;
            return 0;
        }

        public static int deflateTune(z_stream_s strm, int good_length, int max_lazy, int nice_length, int max_chain)
        {
            if (deflateStateCheck(strm) != 0)
                return -2;
            internal_state s = strm.state;
            s.good_match = (uint)good_length;
            s.max_lazy_match = (uint)max_lazy;
            s.nice_match = nice_length;
            s.max_chain_length = (uint)max_chain;
            return 0;
        }

        public static int deflateBound(z_stream_s strm, int sourceLen)
        {
            int complen = sourceLen + ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 5;
            if (deflateStateCheck(strm) != 0)
                return complen + 6;

            internal_state s = strm.state;
            int wraplen;
            switch (s.wrap)
            {
                case 0:
                    wraplen = 0;
                    break;
                case 1:
                    wraplen = 6 + (s.strstart != 0 ? 4 : 0);
                    break;
                case 2:
                    wraplen = 18;
                    if (s.gzhead != null)
                    {
                        byte* str;
                        if (s.gzhead.extra != null)
                            wraplen += (int)(2 + s.gzhead.extra_len);
                        str = s.gzhead.name;
                        if (str != null)
                            do
                            {
                                wraplen++;
                            }
                            while ((*str++) != 0);
                        str = s.gzhead.comment;
                        if (str != null)
                            do
                            {
                                wraplen++;
                            }
                            while ((*str++) != 0);
                        if (s.gzhead.hcrc != 0)
                            wraplen += 2;
                    }
                    break;
                default:
                    wraplen = 6;
                    break;
            }

            if ((s.w_bits != 15) || (s.hash_bits != 8 + 7))
                return complen + wraplen;
            return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) + (sourceLen >> 25) + 13 - 6 + wraplen;
        }

        public static void putShortMSB(internal_state s, uint b)
        {
            {
                s.pending_buf[s.pending++] = (byte)(b >> 8);
            }

            {
                s.pending_buf[s.pending++] = (byte)(b & 0xff);
            }

        }

        public static void flush_pending(z_stream_s strm)
        {
            internal_state s = strm.state;
            _tr_flush_bits(s);
            int len = s.pending;
            if (len > strm.avail_out)
                len = strm.avail_out;
            if (len == 0)
                return;

            s.pending_out.Slice(0, len).CopyTo(strm.next_out);

            strm.next_out = strm.next_out.Slice(len);
            s.pending_out = s.pending_out.Slice(len);
            strm.total_out += len;
            strm.avail_out -= len;
            s.pending -= len;
            if (s.pending == 0)
            {
                s.pending_out = s.pending_buf;
            }

        }

        public static int deflate(z_stream_s strm, int flush)
        {
            if ((deflateStateCheck(strm) != 0) || (flush > 5) || (flush < 0))
            {
                return -2;
            }

            internal_state s = strm.state;
            if ((s.status == 666) && (flush != 4))
            {
                strm.msg = z_errmsg[2 - (-2)];
                return -2;
            }

            if (strm.avail_out == 0)
            {
                strm.msg = z_errmsg[2 - (-5)];
                return -5;
            }
            int old_flush = s.last_flush;
            s.last_flush = flush;
            if (s.pending != 0)
            {
                flush_pending(strm);
                if (strm.avail_out == 0)
                {
                    s.last_flush = -1;
                    return 0;
                }
            }
            else if ((strm.avail_in == 0) && (((flush * 2) - (flush > 4 ? 9 : 0)) <= ((old_flush * 2) - (old_flush > 4 ? 9 : 0))) && (flush != 4))
            {
                strm.msg = z_errmsg[2 - (-5)];
                return -5;
            }

            if ((s.status == 666) && (strm.avail_in != 0))
            {
                strm.msg = z_errmsg[2 - (-5)];
                return -5;
            }

            if (s.status == 42)
            {
                uint header = (uint)((8 + ((s.w_bits - 8) << 4)) << 8);
                uint level_flags = 0;
                if ((s.strategy >= 2) || (s.level < 2))
                    level_flags = 0;
                else if (s.level < 6)
                    level_flags = 1;
                else if (s.level == 6)
                    level_flags = 2;
                else
                    level_flags = 3;
                header |= level_flags << 6;
                if (s.strstart != 0)
                    header |= 32;
                header += 31 - (header % 31);
                putShortMSB(s, header);
                if (s.strstart != 0)
                {
                    putShortMSB(s, (uint)(strm.checksum >> 16));
                    putShortMSB(s, (uint)(strm.checksum & 0xffff));
                }
                strm.checksum = adler32(0, default);
                s.status = 113;
                flush_pending(strm);
                if (s.pending != 0)
                {
                    s.last_flush = -1;
                    return 0;
                }
            }

            if (s.status == 57)
            {
                strm.checksum = crc32(0, default);
                {
                    s.pending_buf[s.pending++] = 31;
                }
                {
                    s.pending_buf[s.pending++] = 139;
                }
                {
                    s.pending_buf[s.pending++] = 8;
                }
                if (s.gzhead == null)
                {
                    {
                        s.pending_buf[s.pending++] = 0;
                    }
                    {
                        s.pending_buf[s.pending++] = 0;
                    }
                    {
                        s.pending_buf[s.pending++] = 0;
                    }
                    {
                        s.pending_buf[s.pending++] = 0;
                    }
                    {
                        s.pending_buf[s.pending++] = 0;
                    }
                    {
                        s.pending_buf[s.pending++] = (byte)(s.level == 9 ? 2 : ((s.strategy >= 2) || (s.level < 2) ? 4 : 0));
                    }
                    {
                        s.pending_buf[s.pending++] = 10;
                    }
                    s.status = 113;
                    flush_pending(strm);
                    if (s.pending != 0)
                    {
                        s.last_flush = -1;
                        return 0;
                    }
                }
                else
                {
                    {
                        s.pending_buf[s.pending++] = (byte)((s.gzhead.text != 0 ? 1 : 0) + (s.gzhead.hcrc != 0 ? 2 : 0) + (s.gzhead.extra == null ? 0 : 4) + (s.gzhead.name == null ? 0 : 8) + (s.gzhead.comment == null ? 0 : 16));
                    }
                    {
                        s.pending_buf[s.pending++] = (byte)(s.gzhead.time & 0xff);
                    }
                    {
                        s.pending_buf[s.pending++] = (byte)((s.gzhead.time >> 8) & 0xff);
                    }
                    {
                        s.pending_buf[s.pending++] = (byte)((s.gzhead.time >> 16) & 0xff);
                    }
                    {
                        s.pending_buf[s.pending++] = (byte)((s.gzhead.time >> 24) & 0xff);
                    }
                    {
                        s.pending_buf[s.pending++] = (byte)(s.level == 9 ? 2 : ((s.strategy >= 2) || (s.level < 2) ? 4 : 0));
                    }
                    {
                        s.pending_buf[s.pending++] = (byte)(s.gzhead.os & 0xff);
                    }
                    if (s.gzhead.extra != null)
                    {
                        {
                            s.pending_buf[s.pending++] = (byte)(s.gzhead.extra_len & 0xff);
                        }
                        {
                            s.pending_buf[s.pending++] = (byte)((s.gzhead.extra_len >> 8) & 0xff);
                        }
                    }
                    if (s.gzhead.hcrc != 0)
                        strm.checksum = crc32(strm.checksum, s.pending_buf.AsSpan(0, s.pending));
                    s.gzindex = 0;
                    s.status = 69;
                }
            }

            if (s.status == 69)
            {
                if (s.gzhead.extra != null)
                {
                    int beg = s.pending;
                    int left = ((s.gzhead.extra_len & 0xffff) - s.gzindex);
                    while ((s.pending + left) > s.pending_buf_size)
                    {
                        int copy = (s.pending_buf_size - s.pending);
                        s.gzhead.extra.AsSpan(s.gzindex, copy).CopyTo(s.pending_buf.AsSpan(s.pending));
                        s.pending = s.pending_buf_size;
                        do
                        {
                            if ((s.gzhead.hcrc != 0) && (s.pending > beg))
                                strm.checksum = crc32(strm.checksum, s.pending_buf.AsSpan(beg, s.pending - beg));
                        }
                        while (0 != 0);
                        s.gzindex += (int)copy;
                        flush_pending(strm);
                        if (s.pending != 0)
                        {
                            s.last_flush = -1;
                            return 0;
                        }
                        beg = 0;
                        left -= copy;
                    }
                    s.gzhead.extra.AsSpan(s.gzindex, left).CopyTo(s.pending_buf.AsSpan(s.pending));
                    s.pending += (int)left;
                    do
                    {
                        if ((s.gzhead.hcrc != 0) && (s.pending > beg))
                            strm.checksum = crc32(strm.checksum, s.pending_buf.AsSpan(beg, s.pending - beg));
                    }
                    while (0 != 0);
                    s.gzindex = 0;
                }
                s.status = 73;
            }

            if (s.status == 73)
            {
                if (s.gzhead.name != null)
                {
                    int beg = s.pending;
                    int val = 0;
                    do
                    {
                        if (s.pending == s.pending_buf_size)
                        {
                            do
                            {
                                if ((s.gzhead.hcrc != 0) && (s.pending > beg))
                                    strm.checksum = crc32(strm.checksum, s.pending_buf.AsSpan(beg, s.pending - beg));
                            }
                            while (0 != 0);
                            flush_pending(strm);
                            if (s.pending != 0)
                            {
                                s.last_flush = -1;
                                return 0;
                            }
                            beg = 0;
                        }
                        val = s.gzhead.name[s.gzindex++];
                        {
                            s.pending_buf[s.pending++] = (byte)val;
                        }
                    }
                    while (val != 0);
                    do
                    {
                        if ((s.gzhead.hcrc != 0) && (s.pending > beg))
                            strm.checksum = crc32(strm.checksum, s.pending_buf.AsSpan(beg, s.pending - beg));
                    }
                    while (0 != 0);
                    s.gzindex = 0;
                }
                s.status = 91;
            }

            if (s.status == 91)
            {
                if (s.gzhead.comment != null)
                {
                    int beg = s.pending;
                    int val = 0;
                    do
                    {
                        if (s.pending == s.pending_buf_size)
                        {
                            do
                            {
                                if ((s.gzhead.hcrc != 0) && (s.pending > beg))
                                    strm.checksum = crc32(strm.checksum, s.pending_buf.AsSpan(beg, s.pending - beg));
                            }
                            while (0 != 0);
                            flush_pending(strm);
                            if (s.pending != 0)
                            {
                                s.last_flush = -1;
                                return 0;
                            }
                            beg = 0;
                        }
                        val = s.gzhead.comment[s.gzindex++];
                        {
                            s.pending_buf[s.pending++] = (byte)val;
                        }
                    }
                    while (val != 0);
                    do
                    {
                        if ((s.gzhead.hcrc != 0) && (s.pending > beg))
                            strm.checksum = crc32(strm.checksum, s.pending_buf.AsSpan(beg, s.pending - beg));
                    }
                    while (0 != 0);
                }
                s.status = 103;
            }

            if (s.status == 103)
            {
                if (s.gzhead.hcrc != 0)
                {
                    if ((s.pending + 2) > s.pending_buf_size)
                    {
                        flush_pending(strm);
                        if (s.pending != 0)
                        {
                            s.last_flush = -1;
                            return 0;
                        }
                    }
                    {
                        s.pending_buf[s.pending++] = (byte)(strm.checksum & 0xff);
                    }
                    {
                        s.pending_buf[s.pending++] = (byte)((strm.checksum >> 8) & 0xff);
                    }
                    strm.checksum = crc32(0, default);
                }
                s.status = 113;
                flush_pending(strm);
                if (s.pending != 0)
                {
                    s.last_flush = -1;
                    return 0;
                }
            }

            if ((strm.avail_in != 0) || (s.lookahead != 0) || ((flush != 0) && (s.status != 666)))
            {
                block_state bstate = 0;
                bstate =
                    s.level == 0 ? deflate_stored(s, flush)
                    : s.strategy == 2 ? deflate_huff(s, flush)
                    : s.strategy == 3 ? deflate_rle(s, flush)
                    : configuration_table[s.level].func(s, flush);

                if ((bstate == block_state.finish_started) || (bstate == block_state.finish_done))
                {
                    s.status = 666;
                }
                if ((bstate == need_more) || (bstate == block_state.finish_started))
                {
                    if (strm.avail_out == 0)
                    {
                        s.last_flush = -1;
                    }
                    return 0;
                }
                if (bstate == block_state.block_done)
                {
                    if (flush == 1)
                    {
                        _tr_align(s);
                    }
                    else if (flush != 5)
                    {
                        _tr_stored_block(s, default, 0, 0);
                        if (flush == 3)
                        {
                            s.head.AsSpan().Clear();
                            if (s.lookahead == 0)
                            {
                                s.strstart = 0;
                                s.block_start = 0;
                                s.insert = 0;
                            }
                        }
                    }
                    flush_pending(strm);
                    if (strm.avail_out == 0)
                    {
                        s.last_flush = -1;
                        return 0;
                    }
                }
            }

            if (flush != 4)
                return 0;
            if (s.wrap <= 0)
                return 1;
            if (s.wrap == 2)
            {
                {
                    s.pending_buf[s.pending++] = (byte)(strm.checksum & 0xff);
                }
                {
                    s.pending_buf[s.pending++] = (byte)((strm.checksum >> 8) & 0xff);
                }
                {
                    s.pending_buf[s.pending++] = (byte)((strm.checksum >> 16) & 0xff);
                }
                {
                    s.pending_buf[s.pending++] = (byte)((strm.checksum >> 24) & 0xff);
                }
                {
                    s.pending_buf[s.pending++] = (byte)(strm.total_in & 0xff);
                }
                {
                    s.pending_buf[s.pending++] = (byte)((strm.total_in >> 8) & 0xff);
                }
                {
                    s.pending_buf[s.pending++] = (byte)((strm.total_in >> 16) & 0xff);
                }
                {
                    s.pending_buf[s.pending++] = (byte)((strm.total_in >> 24) & 0xff);
                }
            }
            else
            {
                putShortMSB(s, (uint)(strm.checksum >> 16));
                putShortMSB(s, (uint)(strm.checksum & 0xffff));
            }

            flush_pending(strm);
            if (s.wrap > 0)
                s.wrap = -s.wrap;
            return s.pending != 0 ? 0 : 1;
        }

        public static int deflateEnd(z_stream_s strm)
        {
            if (deflateStateCheck(strm) != 0)
                return -2;
            int status = strm.state.status;
            {
                strm.state.pending_buf = null;
            }

            {
                strm.state.head = null;
            }

            {
                strm.state.prev = null;
            }

            {
                strm.state.window = null;
            }

            strm.state = null;

            return status == 113 ? (-3) : 0;
        }

        public static int read_buf(z_stream_s strm, Span<byte> buf)
        {
            int len = strm.avail_in;
            if (len > buf.Length)
                len = buf.Length;
            if (len == 0)
                return 0;
            strm.avail_in -= len;
            strm.next_in.Span.Slice(strm.next_in_off, len).CopyTo(buf);

            if (strm.state.wrap == 1)
            {
                strm.checksum = adler32(strm.checksum, buf.Slice(0, len));
            }
            else if (strm.state.wrap == 2)
            {
                strm.checksum = crc32(strm.checksum, buf.Slice(0, len));
            }

            strm.next_in_off += len;
            strm.total_in += len;
            return len;
        }

        public static void lm_init(internal_state s)
        {
            s.window_size = (int)(2L * s.w_size);
            s.head.AsSpan().Clear();
            s.max_lazy_match = configuration_table[s.level].max_lazy;
            s.good_match = configuration_table[s.level].good_length;
            s.nice_match = configuration_table[s.level].nice_length;
            s.max_chain_length = configuration_table[s.level].max_chain;
            s.strstart = 0;
            s.block_start = 0;
            s.lookahead = 0;
            s.insert = 0;
            s.match_length = s.prev_length = 3 - 1;
            s.match_available = 0;
            s.ins_h = 0;
        }

        public static int longest_match(internal_state s, int cur_match)
        {
            uint chain_length = s.max_chain_length;
            Span<byte> scan = s.window.AsSpan(s.strstart);
            int len = 0;
            int best_len = s.prev_length;
            int nice_match = s.nice_match;
            int limit = s.strstart > (s.w_size - (258 + 3 + 1)) ? s.strstart - (s.w_size - (258 + 3 + 1)) : 0;
            ushort[] prev = s.prev;
            int wmask = s.w_mask;
            Span<byte> strend = s.window.AsSpan(s.strstart + 258);
            byte scan_end1 = scan[best_len - 1];
            byte scan_end = scan[best_len];
            if (s.prev_length >= s.good_match)
            {
                chain_length >>= 2;
            }

            if (((uint)nice_match) > s.lookahead)
                nice_match = s.lookahead;

            int scanoffset = 0;
            int matchoffset = 0;
            Span<byte> match;
            do
            {
                match = s.window.AsSpan(cur_match);
                if (
                    (match[best_len] != scan_end) ||
                    (match[best_len - 1] != scan_end1) ||
                    (match[matchoffset] != scan[scanoffset]) ||
                    (match[++matchoffset] != scan[scanoffset + 1]))
                    continue;

                scanoffset += 2;
                matchoffset++;
                do
                {
                }
                while (
                (scan[++scanoffset] == match[++matchoffset]) &&
                (scan[++scanoffset] == match[++matchoffset]) &&
                (scan[++scanoffset] == match[++matchoffset]) &&
                (scan[++scanoffset] == match[++matchoffset]) &&
                (scan[++scanoffset] == match[++matchoffset]) &&
                (scan[++scanoffset] == match[++matchoffset]) &&
                (scan[++scanoffset] == match[++matchoffset]) &&
                (scan[++scanoffset] == match[++matchoffset]) &&
                Unsafe.IsAddressLessThan(ref scan[scanoffset], ref strend[0]));

                len = 258 - (int)Unsafe.ByteOffset(ref scan[scanoffset], ref strend[0]);
                scan = s.window.AsSpan(s.strstart);
                if (len > best_len)
                {
                    s.match_start = cur_match;
                    best_len = len;
                    if (len >= nice_match)
                        break;
                    scan_end1 = scan[best_len - 1];
                    scan_end = scan[best_len];
                }
            }
            while (((cur_match = prev[cur_match & wmask]) > limit) && (--chain_length != 0));
            if ((uint)best_len <= s.lookahead)
                return best_len;
            return s.lookahead;
        }

        public static void fill_window(internal_state s)
        {
            int wsize = s.w_size;
            do
            {
                int more = s.window_size - s.lookahead - s.strstart;
                //if (sizeof(int) <= 2)
                //{
                //    if ((more == 0) && (s.strstart == 0) && (s.lookahead == 0))
                //    {
                //        more = wsize;
                //    }
                //    else if (more == (-1))
                //    {
                //        more--;
                //    }
                //}
                if (s.strstart >= (wsize + (s.w_size - (258 + 3 + 1))))
                {
                    s.window.AsSpan(wsize, wsize - more).CopyTo(s.window);
                    s.match_start -= wsize;
                    s.strstart -= wsize;
                    s.block_start -= wsize;
                    slide_hash(s);
                    more += wsize;
                }
                if (s.strm.avail_in == 0)
                    break;
                int n = read_buf(s.strm, s.window.AsSpan(s.strstart + s.lookahead, more));
                s.lookahead += n;
                if ((s.lookahead + s.insert) >= 3)
                {
                    int str = s.strstart - s.insert;
                    s.ins_h = s.window[str];
                    s.ins_h = (((s.ins_h) << s.hash_shift) ^ (s.window[str + 1])) & s.hash_mask;
                    while (s.insert != 0)
                    {
                        s.ins_h = (((s.ins_h) << s.hash_shift) ^ (s.window[str + 3 - 1])) & s.hash_mask;
                        s.prev[str & s.w_mask] = s.head[s.ins_h];
                        s.head[s.ins_h] = (ushort)str;
                        str++;
                        s.insert--;
                        if ((s.lookahead + s.insert) < 3)
                            break;
                    }
                }
            }
            while ((s.lookahead < (258 + 3 + 1)) && (s.strm.avail_in != 0));
            if (s.high_water < s.window_size)
            {
                int curr = s.strstart + s.lookahead;
                int init;
                if (s.high_water < curr)
                {
                    init = s.window_size - curr;
                    if (init > 258)
                        init = 258;
                    s.window.AsSpan(curr, init).Clear();
                    s.high_water = curr + init;
                }
                else if (s.high_water < (curr + 258))
                {
                    init = curr + 258 - s.high_water;
                    if (init > (s.window_size - s.high_water))
                        init = s.window_size - s.high_water;
                    s.window.AsSpan(s.high_water, init).Clear();
                    s.high_water += init;
                }
            }

        }

        public static block_state deflate_stored(internal_state s, int flush)
        {
            int min_block = (s.pending_buf_size - 5) > s.w_size ? s.w_size : (s.pending_buf_size - 5);
            int last = 0;
            int used = s.strm.avail_in;
            int len;
            int left;
            int have;
            do
            {
                len = 65535;
                have = (s.bi_valid + 42) >> 3;
                if (s.strm.avail_out < have)
                    break;
                have = s.strm.avail_out - have;
                left = s.strstart - s.block_start;
                if (len > (left + s.strm.avail_in))
                    len = left + s.strm.avail_in;
                if (len > have)
                    len = have;
                if ((len < min_block) && (((len == 0) && (flush != 4)) || (flush == 0) || (len != left + s.strm.avail_in)))
                    break;
                last = (flush == 4) && (len == (left + s.strm.avail_in)) ? 1 : 0;
                _tr_stored_block(s, default, 0, last);
                s.pending_buf[s.pending - 4] = (byte)len;
                s.pending_buf[s.pending - 3] = (byte)(len >> 8);
                s.pending_buf[s.pending - 2] = (byte)~len;
                s.pending_buf[s.pending - 1] = (byte)(~len >> 8);
                flush_pending(s.strm);
                if (left != 0)
                {
                    if (left > len)
                        left = len;
                    s.window.AsMemory(s.block_start, left).CopyTo(s.strm.next_out);
                    s.strm.next_out = s.strm.next_out.Slice(left);
                    s.strm.avail_out -= left;
                    s.strm.total_out += left;
                    s.block_start += left;
                    len -= left;
                }
                if (len != 0)
                {
                    read_buf(s.strm, s.strm.next_out.Span.Slice(0, len));
                    s.strm.next_out = s.strm.next_out.Slice(len);
                    s.strm.avail_out -= len;
                    s.strm.total_out += len;
                }
            }
            while (last == 0);
            used -= s.strm.avail_in;
            if (used != 0)
            {
                if (used >= s.w_size)
                {
                    s.matches = 2;
                    s.strm.next_in.Slice(s.strm.next_in_off - s.w_size, s.w_size).CopyTo(s.window);
                    s.strstart = s.w_size;
                }
                else
                {
                    if (s.window_size - s.strstart <= used)
                    {
                        s.strstart -= s.w_size;
                        s.window.AsSpan(s.w_size, s.strstart).CopyTo(s.window);
                        if (s.matches < 2)
                            s.matches++;
                    }
                    s.strm.next_in.Slice(s.strm.next_in_off - used, used).CopyTo(s.window.AsMemory(s.strstart));
                    s.strstart += used;
                }
                s.block_start = s.strstart;
                s.insert += used > (s.w_size - s.insert) ? (s.w_size - s.insert) : used;
            }

            if (s.high_water < s.strstart)
                s.high_water = s.strstart;
            if (last != 0)
                return block_state.finish_done;
            if ((flush != 0) && (flush != 4) && (s.strm.avail_in == 0) && (s.strstart == s.block_start))
                return block_state.block_done;
            have = s.window_size - s.strstart - 1;
            if ((s.strm.avail_in > have) && (s.block_start >= s.w_size))
            {
                s.block_start -= s.w_size;
                s.strstart -= s.w_size;
                s.window.AsSpan(s.w_size, s.strstart).CopyTo(s.window);
                if (s.matches < 2)
                    s.matches++;
                have += s.w_size;
            }

            if (have > s.strm.avail_in)
                have = s.strm.avail_in;
            if (have != 0)
            {
                read_buf(s.strm, s.window.AsSpan(s.strstart, have));
                s.strstart += have;
            }

            if (s.high_water < s.strstart)
                s.high_water = s.strstart;
            have = (s.bi_valid + 42) >> 3;
            have = (s.pending_buf_size - have) > 65535 ? 65535 : (s.pending_buf_size - have);
            min_block = have > s.w_size ? s.w_size : have;
            left = s.strstart - s.block_start;
            if ((left >= min_block) || (((left != 0) || (flush == 4)) && (flush != 0) && (s.strm.avail_in == 0) && (left <= have)))
            {
                len = left > have ? have : left;
                last = (flush == 4) && (s.strm.avail_in == 0) && (len == left) ? 1 : 0;
                _tr_stored_block(s, s.window.AsSpan(s.block_start), len, last);
                s.block_start += len;
                flush_pending(s.strm);
            }

            return (block_state)(last != 0 ? finish_started : need_more);
        }

        public static block_state deflate_fast(internal_state s, int flush)
        {
            var d_buf = MemoryMarshal.Cast<byte, ushort>(s.d_buf.Span);
            var l_buf = s.l_buf.Span;
            for (; ; )
            {
                if (s.lookahead < (258 + 3 + 1))
                {
                    fill_window(s);
                    if ((s.lookahead < (258 + 3 + 1)) && (flush == 0))
                    {
                        return block_state.need_more;
                    }
                    if (s.lookahead == 0)
                        break;
                }
                int hash_head = 0;
                if (s.lookahead >= 3)
                {
                    s.ins_h = (((s.ins_h) << s.hash_shift) ^ (s.window[s.strstart + (3 - 1)])) & s.hash_mask;
                    hash_head = s.prev[(s.strstart) & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = (ushort)s.strstart;
                }
                if ((hash_head != 0) && (s.strstart - hash_head <= (s.w_size - (258 + 3 + 1))))
                {
                    s.match_length = longest_match(s, hash_head);
                }

                int bflush;
                if (s.match_length >= 3)
                {
                    {
                        byte len = (byte)(s.match_length - 3);
                        ushort dist = (ushort)(s.strstart - s.match_start);
                        d_buf[s.last_lit] = dist;
                        l_buf[s.last_lit++] = len;
                        dist--;
                        s.dyn_ltree[_length_code[len] + 256 + 1].fc.freq++;
                        s.dyn_dtree[dist < 256 ? _dist_code[dist] : _dist_code[256 + ((dist) >> 7)]].fc.freq++;
                        bflush = s.last_lit == (s.lit_bufsize - 1) ? 1 : 0;
                    }
                    s.lookahead -= s.match_length;
                    if ((s.match_length <= s.max_lazy_match) && (s.lookahead >= 3))
                    {
                        s.match_length--;
                        do
                        {
                            s.strstart++;
                            s.ins_h = (((s.ins_h) << s.hash_shift) ^ (s.window[s.strstart + (3 - 1)])) & s.hash_mask;
                            hash_head = s.prev[(s.strstart) & s.w_mask] = s.head[s.ins_h];
                            s.head[s.ins_h] = (ushort)s.strstart;
                        }
                        while (--s.match_length != 0);
                        s.strstart++;
                    }
                    else
                    {
                        s.strstart += s.match_length;
                        s.match_length = 0;
                        s.ins_h = s.window[s.strstart];
                        s.ins_h = (((s.ins_h) << s.hash_shift) ^ (s.window[s.strstart + 1])) & s.hash_mask;
                    }
                }
                else
                {
                    {
                        byte cc = s.window[s.strstart];
                        d_buf[s.last_lit] = 0;
                        l_buf[s.last_lit++] = cc;
                        s.dyn_ltree[cc].fc.freq++;
                        bflush = s.last_lit == (s.lit_bufsize - 1) ? 1 : 0;
                    }
                    s.lookahead--;
                    s.strstart++;
                }
                if (bflush != 0)
                {
                    {
                        _tr_flush_block(s, s.block_start >= 0L ? s.window.AsSpan(s.block_start) : default, s.strstart - s.block_start, 0);
                        s.block_start = s.strstart;
                        flush_pending(s.strm);
                    }
                    if (s.strm.avail_out == 0)
                        return block_state.need_more;
                }
            }
            s.insert = s.strstart < (3 - 1) ? s.strstart : 3 - 1;
            if (flush == 4)
            {
                {
                    {
                        _tr_flush_block(s, s.block_start >= 0L ? s.window.AsSpan(s.block_start) : default, s.strstart - s.block_start, 1);
                        s.block_start = s.strstart;
                        flush_pending(s.strm);
                    }
                    if (s.strm.avail_out == 0)
                        return block_state.finish_started;
                }
                return block_state.finish_done;
            }

            if (s.last_lit != 0)
            {
                {
                    _tr_flush_block(s, s.block_start >= 0L ? s.window.AsSpan(s.block_start) : default, s.strstart - s.block_start, 0);
                    s.block_start = s.strstart;
                    flush_pending(s.strm);
                }
                if (s.strm.avail_out == 0)
                    return block_state.need_more;
            }

            return block_state.block_done;
        }

        public static block_state deflate_slow(internal_state s, int flush)
        {
            var d_buf = MemoryMarshal.Cast<byte, ushort>(s.d_buf.Span);
            var l_buf = s.l_buf.Span;
            int bflush;
            for (; ; )
            {
                if (s.lookahead < (258 + 3 + 1))
                {
                    fill_window(s);
                    if ((s.lookahead < (258 + 3 + 1)) && (flush == 0))
                    {
                        return block_state.need_more;
                    }
                    if (s.lookahead == 0)
                        break;
                }
                int hash_head = 0;
                if (s.lookahead >= 3)
                {
                    s.ins_h = (((s.ins_h) << s.hash_shift) ^ (s.window[s.strstart + (3 - 1)])) & s.hash_mask;
                    hash_head = s.prev[(s.strstart) & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = (ushort)s.strstart;
                }
                s.prev_length = s.match_length;
                s.prev_match = (uint)s.match_start;
                s.match_length = 3 - 1;
                if ((hash_head != 0) && (s.prev_length < s.max_lazy_match) && (s.strstart - hash_head <= (s.w_size - (258 + 3 + 1))))
                {
                    s.match_length = longest_match(s, hash_head);
                    if ((s.match_length <= 5) && ((s.strategy == 1) || ((s.match_length == 3) && ((s.strstart - s.match_start) > 4096))))
                    {
                        s.match_length = 3 - 1;
                    }
                }
                if ((s.prev_length >= 3) && (s.match_length <= s.prev_length))
                {
                    uint max_insert = (uint)(s.strstart + s.lookahead - 3);
                    {
                        byte len = (byte)(s.prev_length - 3);
                        ushort dist = (ushort)(s.strstart - 1 - s.prev_match);
                        d_buf[s.last_lit] = dist;
                        l_buf[s.last_lit++] = len;
                        dist--;
                        s.dyn_ltree[_length_code[len] + 256 + 1].fc.freq++;
                        s.dyn_dtree[dist < 256 ? _dist_code[dist] : _dist_code[256 + ((dist) >> 7)]].fc.freq++;
                        bflush = s.last_lit == (s.lit_bufsize - 1) ? 1 : 0;
                    }
                    s.lookahead -= s.prev_length - 1;
                    s.prev_length -= 2;
                    do
                    {
                        if (++s.strstart <= max_insert)
                        {
                            s.ins_h = (((s.ins_h) << s.hash_shift) ^ (s.window[s.strstart + (3 - 1)])) & s.hash_mask;
                            hash_head = s.prev[(s.strstart) & s.w_mask] = s.head[s.ins_h];
                            s.head[s.ins_h] = (ushort)s.strstart;
                        }
                    }
                    while (--s.prev_length != 0);
                    s.match_available = 0;
                    s.match_length = 3 - 1;
                    s.strstart++;
                    if (bflush != 0)
                    {
                        {
                            _tr_flush_block(s, s.block_start >= 0L ? s.window.AsSpan(s.block_start) : default, s.strstart - s.block_start, 0);
                            s.block_start = s.strstart;
                            flush_pending(s.strm);
                        }
                        if (s.strm.avail_out == 0)
                            return block_state.need_more;
                    }
                }
                else if (s.match_available != 0)
                {
                    {
                        byte cc = s.window[s.strstart - 1];
                        d_buf[s.last_lit] = 0;
                        l_buf[s.last_lit++] = cc;
                        s.dyn_ltree[cc].fc.freq++;
                        bflush = s.last_lit == (s.lit_bufsize - 1) ? 1 : 0;
                    }
                    if (bflush != 0)
                    {
                        {
                            _tr_flush_block(s, s.block_start >= 0L ? s.window.AsSpan(s.block_start) : default, s.strstart - s.block_start, 0);
                            s.block_start = s.strstart;
                            flush_pending(s.strm);
                        }
                    }
                    s.strstart++;
                    s.lookahead--;
                    if (s.strm.avail_out == 0)
                        return block_state.need_more;
                }
                else
                {
                    s.match_available = 1;
                    s.strstart++;
                    s.lookahead--;
                }
            }
            if (s.match_available != 0)
            {
                {
                    byte cc = s.window[s.strstart - 1];
                    d_buf[s.last_lit] = 0;
                    l_buf[s.last_lit++] = cc;
                    s.dyn_ltree[cc].fc.freq++;
                    bflush = s.last_lit == (s.lit_bufsize - 1) ? 1 : 0;
                }
                s.match_available = 0;
            }

            s.insert = s.strstart < (3 - 1) ? s.strstart : 3 - 1;
            if (flush == 4)
            {
                {
                    {
                        _tr_flush_block(s, s.block_start >= 0L ? s.window.AsSpan(s.block_start) : default, s.strstart - s.block_start, 1);
                        s.block_start = s.strstart;
                        flush_pending(s.strm);
                    }
                    if (s.strm.avail_out == 0)
                        return block_state.finish_started;
                }
                return block_state.finish_done;
            }

            if (s.last_lit != 0)
            {
                {
                    _tr_flush_block(s, s.block_start >= 0L ? s.window.AsSpan(s.block_start) : default, s.strstart - s.block_start, 0);
                    s.block_start = s.strstart;
                    flush_pending(s.strm);
                }
                if (s.strm.avail_out == 0)
                    return block_state.need_more;
            }

            return block_state.block_done;
        }

        public static block_state deflate_rle(internal_state s, int flush)
        {
            var d_buf = MemoryMarshal.Cast<byte, ushort>(s.d_buf.Span);
            var l_buf = s.l_buf.Span;

            int bflush = 0;
            uint prev = 0;
            Span<byte> scan;
            Span<byte> strend;
            for (; ; )
            {
                if (s.lookahead <= 258)
                {
                    fill_window(s);
                    if ((s.lookahead <= 258) && (flush == 0))
                    {
                        return block_state.need_more;
                    }
                    if (s.lookahead == 0)
                        break;
                }
                s.match_length = 0;
                if ((s.lookahead >= 3) && (s.strstart > 0))
                {
                    scan = s.window.AsSpan(s.strstart - 1);
                    int scanoffset = 0;
                    prev = scan[0];
                    if ((prev == scan[++scanoffset]) &&
                        (prev == scan[++scanoffset]) &&
                        (prev == scan[++scanoffset]))
                    {
                        strend = s.window.AsSpan(s.strstart + 258);
                        do
                        {
                        }
                        while (
                        (prev == scan[++scanoffset]) &&
                        (prev == scan[++scanoffset]) &&
                        (prev == scan[++scanoffset]) &&
                        (prev == scan[++scanoffset]) &&
                        (prev == scan[++scanoffset]) &&
                        (prev == scan[++scanoffset]) &&
                        (prev == scan[++scanoffset]) &&
                        (prev == scan[++scanoffset]) &&
                        Unsafe.IsAddressLessThan(ref scan[scanoffset], ref strend[0]));

                        s.match_length = 258 - (int)Unsafe.ByteOffset(ref scan[scanoffset], ref strend[0]);
                        if (s.match_length > s.lookahead)
                            s.match_length = s.lookahead;
                    }
                }
                if (s.match_length >= 3)
                {
                    {
                        byte len = (byte)(s.match_length - 3);
                        ushort dist = 1;
                        d_buf[s.last_lit] = dist;
                        l_buf[s.last_lit++] = len;
                        dist--;
                        s.dyn_ltree[_length_code[len] + 256 + 1].fc.freq++;
                        s.dyn_dtree[dist < 256 ? _dist_code[dist] : _dist_code[256 + ((dist) >> 7)]].fc.freq++;
                        bflush = s.last_lit == (s.lit_bufsize - 1) ? 1 : 0;
                    }
                    s.lookahead -= s.match_length;
                    s.strstart += s.match_length;
                    s.match_length = 0;
                }
                else
                {
                    {
                        byte cc = s.window[s.strstart];
                        d_buf[s.last_lit] = 0;
                        l_buf[s.last_lit++] = cc;
                        s.dyn_ltree[cc].fc.freq++;
                        bflush = s.last_lit == (s.lit_bufsize - 1) ? 1 : 0;
                    }
                    s.lookahead--;
                    s.strstart++;
                }
                if (bflush != 0)
                {
                    {
                        _tr_flush_block(s, s.block_start >= 0L ? s.window.AsSpan(s.block_start) : default, s.strstart - s.block_start, 0);
                        s.block_start = s.strstart;
                        flush_pending(s.strm);
                    }
                    if (s.strm.avail_out == 0)
                        return block_state.need_more;
                }
            }
            s.insert = 0;
            if (flush == 4)
            {
                {
                    {
                        _tr_flush_block(s, s.block_start >= 0L ? s.window.AsSpan(s.block_start) : default, s.strstart - s.block_start, 1);
                        s.block_start = s.strstart;
                        flush_pending(s.strm);
                    }
                    if (s.strm.avail_out == 0)
                        return block_state.finish_started;
                }
                return block_state.finish_done;
            }

            if (s.last_lit != 0)
            {
                {
                    _tr_flush_block(s, s.block_start >= 0L ? s.window.AsSpan(s.block_start) : default, s.strstart - s.block_start, 0);
                    s.block_start = s.strstart;
                    flush_pending(s.strm);
                }
                if (s.strm.avail_out == 0)
                    return block_state.need_more;
            }

            return block_state.block_done;
        }

        public static block_state deflate_huff(internal_state s, int flush)
        {
            var d_buf = MemoryMarshal.Cast<byte, ushort>(s.d_buf.Span);
            var l_buf = s.l_buf.Span;

            for (; ; )
            {
                if (s.lookahead == 0)
                {
                    fill_window(s);
                    if (s.lookahead == 0)
                    {
                        if (flush == 0)
                            return block_state.need_more;
                        break;
                    }
                }
                s.match_length = 0;

                int bflush;
                {
                    byte cc = s.window[s.strstart];
                    d_buf[s.last_lit] = 0;
                    l_buf[s.last_lit++] = cc;
                    s.dyn_ltree[cc].fc.freq++;
                    bflush = s.last_lit == (s.lit_bufsize - 1) ? 1 : 0;
                }
                s.lookahead--;
                s.strstart++;
                if (bflush != 0)
                {
                    {
                        _tr_flush_block(s, s.block_start >= 0L ? s.window.AsSpan(s.block_start) : default, s.strstart - s.block_start, 0);
                        s.block_start = s.strstart;
                        flush_pending(s.strm);
                    }
                    if (s.strm.avail_out == 0)
                        return block_state.need_more;
                }
            }
            s.insert = 0;
            if (flush == 4)
            {
                {
                    {
                        _tr_flush_block(s, s.block_start >= 0L ? s.window.AsSpan(s.block_start) : default, s.strstart - s.block_start, 1);
                        s.block_start = s.strstart;
                        flush_pending(s.strm);
                    }
                    if (s.strm.avail_out == 0)
                        return block_state.finish_started;
                }
                return block_state.finish_done;
            }

            if (s.last_lit != 0)
            {
                {
                    _tr_flush_block(s, s.block_start >= 0L ? s.window.AsSpan(s.block_start) : default, s.strstart - s.block_start, 0);
                    s.block_start = s.strstart;
                    flush_pending(s.strm);
                }
                if (s.strm.avail_out == 0)
                    return block_state.need_more;
            }

            return block_state.block_done;
        }

    }
}