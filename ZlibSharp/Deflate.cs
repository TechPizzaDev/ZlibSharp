// Generated by Sichem at 2020-09-30 18:30:50

using System;
using System.Runtime.InteropServices;
using static CRuntime;

namespace ZlibSharp
{
	unsafe class Deflate
	{
		public const int need_more = 0;
		public const int block_done = 1;
		public const int finish_started = 2;
		public const int finish_done = 3;
		public static sbyte*[] z_errmsg = new sbyte[10];
		public static byte[] _length_code = 0;
		public static byte[] _dist_code = 0;
		public static sbyte[] deflate_copyright = " deflate 1.2.11 Copyright 1995-2017 Jean-loup Gailly and Mark Adler ";
		public static config_s[] configuration_table = { { 0, 0, 0, 0, deflate_stored }, { 4, 4, 8, 4, deflate_fast }, { 4, 5, 16, 8, deflate_fast }, { 4, 6, 32, 32, deflate_fast }, { 4, 4, 16, 16, deflate_slow }, { 8, 16, 32, 32, deflate_slow }, { 8, 16, 128, 128, deflate_slow }, { 8, 32, 128, 256, deflate_slow }, { 32, 128, 258, 1024, deflate_slow }, { 32, 258, 258, 4096, deflate_slow } };
		[StructLayout(LayoutKind.Sequential)]
		public class z_stream_s
	{
		public byte* next_in;
		public uint avail_in;
		public int total_in;
		public byte* next_out;
		public uint avail_out;
		public int total_out;
		public string msg;
		public internal_state state;
		public zalloc_delegate zalloc;
		public zfree_delegate zfree;
		public void * opaque;
		public int data_type;
		public int adler;
		public int reserved;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct gz_header_s
	{
		public int text;
		public int time;
		public int xflags;
		public int os;
		public byte* extra;
		public uint extra_len;
		public uint extra_max;
		public byte* name;
		public uint name_max;
		public byte* comment;
		public uint comm_max;
		public int hcrc;
		public int done;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct gzFile_s
	{
		public uint have;
		public byte* next;
		public long pos;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct fc
	{
		public ushort freq;
		public ushort code;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct dl
	{
		public ushort dad;
		public ushort len;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct ct_data_s
	{
		public union ct_data_s::(anonymous at C:\Projects\Repos\ZlibSharp\zlib/deflate.h:69:5) fc;
		public union ct_data_s::(anonymous at C:\Projects\Repos\ZlibSharp\zlib/deflate.h:73:5) dl;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct tree_desc_s
	{
		public ct_data_s* dyn_tree;
		public int max_code;
		public static_tree_desc_s* stat_desc;
		}
		[StructLayout(LayoutKind.Sequential)]
		public class internal_state
	{
		public z_stream_s strm;
		public int status;
		public byte* pending_buf;
		public int pending_buf_size;
		public byte* pending_out;
		public int pending;
		public int wrap;
		public gz_header_s* gzhead;
		public int gzindex;
		public byte method;
		public int last_flush;
		public uint w_size;
		public uint w_bits;
		public uint w_mask;
		public byte* window;
		public int window_size;
		public ushort* prev;
		public ushort* head;
		public uint ins_h;
		public uint hash_size;
		public uint hash_bits;
		public uint hash_mask;
		public uint hash_shift;
		public int block_start;
		public uint match_length;
		public uint prev_match;
		public int match_available;
		public uint strstart;
		public uint match_start;
		public uint lookahead;
		public uint prev_length;
		public uint max_chain_length;
		public uint max_lazy_match;
		public int level;
		public int strategy;
		public uint good_match;
		public int nice_match;
		public fixed ct_data_s dyn_ltree[(2 * (256 + 1 + 29) + 1)];
		public fixed ct_data_s dyn_dtree[2 * 30 + 1];
		public fixed ct_data_s bl_tree[2 * 19 + 1];
		public tree_desc_s l_desc;
		public tree_desc_s d_desc;
		public tree_desc_s bl_desc;
		public fixed ushort bl_count[15 + 1];
		public fixed int heap[2 * (256 + 1 + 29) + 1];
		public int heap_len;
		public int heap_max;
		public fixed byte depth[2 * (256 + 1 + 29) + 1];
		public byte* l_buf;
		public uint lit_bufsize;
		public uint last_lit;
		public ushort* d_buf;
		public int opt_len;
		public int static_len;
		public uint matches;
		public uint insert;
		public ushort bi_buf;
		public int bi_valid;
		public int high_water;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct config_s
	{
		public ushort good_length;
		public ushort max_lazy;
		public ushort nice_length;
		public ushort max_chain;
		public deflate_func func;
		}
		public static void slide_hash(internal_state s)
		{
			uint n = 0;uint m = 0;
			ushort* p;
			uint wsize = (uint)(s.w_size);
			n = (uint)(s.hash_size);
			p = &s.head[n];
			do {
m = (uint)(*--p);*p = ((ushort)((m) >= (wsize)?m - wsize:0));}
 while ((--n) != 0);
			n = (uint)(wsize);
			p = &s.prev[n];
			do {
m = (uint)(*--p);*p = ((ushort)((m) >= (wsize)?m - wsize:0));}
 while ((--n) != 0);
		}

		public static int deflateInit_(z_stream_s strm, int level, sbyte* version, int stream_size)
		{
			return (int)(deflateInit2_(strm, (int)(level), (int)(8), (int)(15), (int)(8), (int)(0), version, (int)(stream_size)));
		}

		public static int deflateInit2_(z_stream_s strm, int level, int method, int windowBits, int memLevel, int strategy, sbyte* version, int stream_size)
		{
			internal_state s;
			int wrap = (int)(1);
			sbyte* my_version = "1.2.11";
			ushort* overlay;
			if ((((version) == (null)) || (version[0] != my_version[0])) || (stream_size != sizeof(z_stream_s))) {
return (int)(-6);}

			if ((strm) == (null)) return (int)(-2);
			strm.msg = null;
			if (strm.zalloc == ((zalloc_delegate)(0))) {
strm.zalloc = zcalloc;strm.opaque = (void *)(0);}

			if (strm.zfree == ((zfree_delegate)(0))) strm.zfree = zcfree;
			if ((level) == (-1)) level = (int)(6);
			if ((windowBits) < (0)) {
wrap = (int)(0);windowBits = (int)(-windowBits);}
 else if ((windowBits) > (15)) {
wrap = (int)(2);windowBits -= (int)(16);}

			if (((((((((((memLevel) < (1)) || ((memLevel) > (9))) || (method != 8)) || ((windowBits) < (8))) || ((windowBits) > (15))) || ((level) < (0))) || ((level) > (9))) || ((strategy) < (0))) || ((strategy) > (4))) || (((windowBits) == (8)) && (wrap != 1))) {
return (int)(-2);}

			if ((windowBits) == (8)) windowBits = (int)(9);
			s = (internal_state)(strm.zalloc(strm.opaque, (uint)(1), (uint)(sizeof(internal_state))));
			if ((s) == (null)) return (int)(-4);
			strm.state = s;
			s.strm = strm;
			s.status = (int)(42);
			s.wrap = (int)(wrap);
			s.gzhead = null;
			s.w_bits = ((uint)(windowBits));
			s.w_size = (uint)(1 << s.w_bits);
			s.w_mask = (uint)(s.w_size - 1);
			s.hash_bits = (uint)((uint)(memLevel) + 7);
			s.hash_size = (uint)(1 << s.hash_bits);
			s.hash_mask = (uint)(s.hash_size - 1);
			s.hash_shift = (uint)((s.hash_bits + 3 - 1) / 3);
			s.window = (byte*)(strm.zalloc(strm.opaque, (uint)(s.w_size), (uint)(2 * sizeof(byte))));
			s.prev = (ushort*)(strm.zalloc(strm.opaque, (uint)(s.w_size), (uint)(sizeof(ushort))));
			s.head = (ushort*)(strm.zalloc(strm.opaque, (uint)(s.hash_size), (uint)(sizeof(ushort))));
			s.high_water = (int)(0);
			s.lit_bufsize = (uint)(1 << (memLevel + 6));
			overlay = (ushort*)(strm.zalloc(strm.opaque, (uint)(s.lit_bufsize), (uint)(sizeof(ushort) + 2)));
			s.pending_buf = (byte*)(overlay);
			s.pending_buf_size = (int)((int)(s.lit_bufsize) * (sizeof(ushort) + 2L));
			if (((((s.window) == (null)) || ((s.prev) == (null))) || ((s.head) == (null))) || ((s.pending_buf) == (null))) {
s.status = (int)(666);strm.msg = z_errmsg[2 - (-4)];deflateEnd(strm);return (int)(-4);}

			s.d_buf = overlay + s.lit_bufsize / sizeof(ushort);
			s.l_buf = s.pending_buf + (1 + sizeof(ushort)) * s.lit_bufsize;
			s.level = (int)(level);
			s.strategy = (int)(strategy);
			s.method = ((byte)(method));
			return (int)(deflateReset(strm));
		}

		public static int deflateStateCheck(z_stream_s strm)
		{
			internal_state s;
			if ((((strm) == (null)) || (strm.zalloc == ((zalloc_delegate)(0)))) || (strm.zfree == ((zfree_delegate)(0)))) return (int)(1);
			s = strm.state;
			if ((((s) == (null)) || (s.strm != strm)) || ((((((((s.status != 42) && (s.status != 57)) && (s.status != 69)) && (s.status != 73)) && (s.status != 91)) && (s.status != 103)) && (s.status != 113)) && (s.status != 666))) return (int)(1);
			return (int)(0);
		}

		public static int deflateSetDictionary(z_stream_s strm, byte* dictionary, uint dictLength)
		{
			internal_state s;
			uint str = 0;uint n = 0;
			int wrap = 0;
			uint avail = 0;
			byte* next;
			if (((deflateStateCheck(strm)) != 0) || ((dictionary) == (null))) return (int)(-2);
			s = strm.state;
			wrap = (int)(s.wrap);
			if ((((wrap) == (2)) || (((wrap) == (1)) && (s.status != 42))) || ((s.lookahead) != 0)) return (int)(-2);
			if ((wrap) == (1)) strm.adler = (int)(adler32((int)(strm.adler), dictionary, (uint)(dictLength)));
			s.wrap = (int)(0);
			if ((dictLength) >= (s.w_size)) {
if ((wrap) == (0)) {
s.head[s.hash_size - 1] = (ushort)(0);memset((byte*)(s.head), (int)(0), (ulong)((s.hash_size - 1) * sizeof((*s.head))));s.strstart = (uint)(0);s.block_start = (int)(0L);s.insert = (uint)(0);}
dictionary += dictLength - s.w_size;dictLength = (uint)(s.w_size);}

			avail = (uint)(strm.avail_in);
			next = strm.next_in;
			strm.avail_in = (uint)(dictLength);
			strm.next_in = dictionary;
			fill_window(s);
			while ((s.lookahead) >= (3)) {
str = (uint)(s.strstart);n = (uint)(s.lookahead - (3 - 1));do {
(s.ins_h = (uint)((((s.ins_h) << s.hash_shift) ^ (s.window[str + 3 - 1])) & s.hash_mask));s.prev[str & s.w_mask] = (ushort)(s.head[s.ins_h]);s.head[s.ins_h] = ((ushort)(str));str++;}
 while ((--n) != 0);s.strstart = (uint)(str);s.lookahead = (uint)(3 - 1);fill_window(s);}
			s.strstart += (uint)(s.lookahead);
			s.block_start = ((int)(s.strstart));
			s.insert = (uint)(s.lookahead);
			s.lookahead = (uint)(0);
			s.match_length = (uint)(s.prev_length = (uint)(3 - 1));
			s.match_available = (int)(0);
			strm.next_in = next;
			strm.avail_in = (uint)(avail);
			s.wrap = (int)(wrap);
			return (int)(0);
		}

		public static int deflateGetDictionary(z_stream_s strm, byte* dictionary, uint* dictLength)
		{
			internal_state s;
			uint len = 0;
			if ((deflateStateCheck(strm)) != 0) return (int)(-2);
			s = strm.state;
			len = (uint)(s.strstart + s.lookahead);
			if ((len) > (s.w_size)) len = (uint)(s.w_size);
			if ((dictionary != null) && ((len) != 0)) memcpy(dictionary, s.window + s.strstart + s.lookahead - len, (ulong)(len));
			if (dictLength != null) *dictLength = (uint)(len);
			return (int)(0);
		}

		public static int deflateResetKeep(z_stream_s strm)
		{
			internal_state s;
			if ((deflateStateCheck(strm)) != 0) {
return (int)(-2);}

			strm.total_in = (int)(strm.total_out = (int)(0));
			strm.msg = null;
			strm.data_type = (int)(2);
			s = strm.state;
			s.pending = (int)(0);
			s.pending_out = s.pending_buf;
			if ((s.wrap) < (0)) {
s.wrap = (int)(-s.wrap);}

			s.status = (int)((s.wrap) == (2)?57:(s.wrap) != 0?42:113);
			strm.adler = (int)((s.wrap) == (2)?crc32((int)(0L), null, (uint)(0)):adler32((int)(0L), null, (uint)(0)));
			s.last_flush = (int)(0);
			_tr_init(s);
			return (int)(0);
		}

		public static int deflateReset(z_stream_s strm)
		{
			int ret = 0;
			ret = (int)(deflateResetKeep(strm));
			if ((ret) == (0)) lm_init(strm.state);
			return (int)(ret);
		}

		public static int deflateSetHeader(z_stream_s strm, gz_header_s* head)
		{
			if (((deflateStateCheck(strm)) != 0) || (strm.state.wrap != 2)) return (int)(-2);
			strm.state.gzhead = head;
			return (int)(0);
		}

		public static int deflatePending(z_stream_s strm, uint* pending, int* bits)
		{
			if ((deflateStateCheck(strm)) != 0) return (int)(-2);
			if (pending != null) *pending = (uint)(strm.state.pending);
			if (bits != null) *bits = (int)(strm.state.bi_valid);
			return (int)(0);
		}

		public static int deflatePrime(z_stream_s strm, int bits, int value)
		{
			internal_state s;
			int put = 0;
			if ((deflateStateCheck(strm)) != 0) return (int)(-2);
			s = strm.state;
			if (((byte*)(s.d_buf)) < (s.pending_out + ((16 + 7) >> 3))) return (int)(-5);
			do {
put = (int)(16 - s.bi_valid);if ((put) > (bits)) put = (int)(bits);s.bi_buf |= ((ushort)((value & ((1 << put) - 1)) << s.bi_valid));s.bi_valid += (int)(put);_tr_flush_bits(s);value >>= put;bits -= (int)(put);}
 while ((bits) != 0);
			return (int)(0);
		}

		public static int deflateParams(z_stream_s strm, int level, int strategy)
		{
			internal_state s;
			deflate_func func;
			if ((deflateStateCheck(strm)) != 0) return (int)(-2);
			s = strm.state;
			if ((level) == (-1)) level = (int)(6);
			if (((((level) < (0)) || ((level) > (9))) || ((strategy) < (0))) || ((strategy) > (4))) {
return (int)(-2);}

			func = configuration_table[s.level].func;
			if (((strategy != s.strategy) || (func != configuration_table[level].func)) && ((s.high_water) != 0)) {
int err = (int)(deflate(strm, (int)(5)));if ((err) == (-2)) return (int)(err);if ((strm.avail_out) == (0)) return (int)(-5);}

			if (s.level != level) {
if (((s.level) == (0)) && (s.matches != 0)) {
if ((s.matches) == (1)) slide_hash(s); else s.head[s.hash_size - 1] = (ushort)(0);memset((byte*)(s.head), (int)(0), (ulong)((s.hash_size - 1) * sizeof((*s.head))));s.matches = (uint)(0);}
s.level = (int)(level);s.max_lazy_match = (uint)(configuration_table[level].max_lazy);s.good_match = (uint)(configuration_table[level].good_length);s.nice_match = (int)(configuration_table[level].nice_length);s.max_chain_length = (uint)(configuration_table[level].max_chain);}

			s.strategy = (int)(strategy);
			return (int)(0);
		}

		public static int deflateTune(z_stream_s strm, int good_length, int max_lazy, int nice_length, int max_chain)
		{
			internal_state s;
			if ((deflateStateCheck(strm)) != 0) return (int)(-2);
			s = strm.state;
			s.good_match = ((uint)(good_length));
			s.max_lazy_match = ((uint)(max_lazy));
			s.nice_match = (int)(nice_length);
			s.max_chain_length = ((uint)(max_chain));
			return (int)(0);
		}

		public static int deflateBound(z_stream_s strm, int sourceLen)
		{
			internal_state s;
			int complen = 0;int wraplen = 0;
			complen = (int)(sourceLen + ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 5);
			if ((deflateStateCheck(strm)) != 0) return (int)(complen + 6);
			s = strm.state;
			switch (s.wrap){
case 0:wraplen = (int)(0);break;case 1:wraplen = (int)(6 + ((s.strstart) != 0?4:0));break;case 2:wraplen = (int)(18);if (s.gzhead != null) {
byte* str;if (s.gzhead->extra != null) wraplen += (int)(2 + s.gzhead->extra_len);str = s.gzhead->name;if (str != null) do {
wraplen++;}
 while ((*str++) != 0);str = s.gzhead->comment;if (str != null) do {
wraplen++;}
 while ((*str++) != 0);if ((s.gzhead->hcrc) != 0) wraplen += (int)(2);}
break;default: wraplen = (int)(6);}

			if ((s.w_bits != 15) || (s.hash_bits != 8 + 7)) return (int)(complen + wraplen);
			return (int)(sourceLen + (sourceLen >> 12) + (sourceLen >> 14) + (sourceLen >> 25) + 13 - 6 + wraplen);
		}

		public static void putShortMSB(internal_state s, uint b)
		{
			{
s.pending_buf[s.pending++] = ((byte)(b >> 8));}

			{
s.pending_buf[s.pending++] = ((byte)(b & 0xff));}

		}

		public static void flush_pending(z_stream_s strm)
		{
			uint len = 0;
			internal_state s = strm.state;
			_tr_flush_bits(s);
			len = (uint)(s.pending);
			if ((len) > (strm.avail_out)) len = (uint)(strm.avail_out);
			if ((len) == (0)) return;
			memcpy(strm.next_out, s.pending_out, (ulong)(len));
			strm.next_out += len;
			s.pending_out += len;
			strm.total_out += (int)(len);
			strm.avail_out -= (uint)(len);
			s.pending -= (int)(len);
			if ((s.pending) == (0)) {
s.pending_out = s.pending_buf;}

		}

		public static int deflate(z_stream_s strm, int flush)
		{
			int old_flush = 0;
			internal_state s;
			if ((((deflateStateCheck(strm)) != 0) || ((flush) > (5))) || ((flush) < (0))) {
return (int)(-2);}

			s = strm.state;
			if ((((strm.next_out) == (null)) || ((strm.avail_in != 0) && ((strm.next_in) == (null)))) || (((s.status) == (666)) && (flush != 4))) {
return (int)(strm.msg = z_errmsg[2 - (-2)] , (-2));}

			if ((strm.avail_out) == (0)) return (int)(strm.msg = z_errmsg[2 - (-5)] , (-5));
			old_flush = (int)(s.last_flush);
			s.last_flush = (int)(flush);
			if (s.pending != 0) {
flush_pending(strm);if ((strm.avail_out) == (0)) {
s.last_flush = (int)(-1);return (int)(0);}
}
 else if ((((strm.avail_in) == (0)) && ((((flush) * 2) - ((flush) > (4)?9:0)) <= (((old_flush) * 2) - ((old_flush) > (4)?9:0)))) && (flush != 4)) {
return (int)(strm.msg = z_errmsg[2 - (-5)] , (-5));}

			if (((s.status) == (666)) && (strm.avail_in != 0)) {
return (int)(strm.msg = z_errmsg[2 - (-5)] , (-5));}

			if ((s.status) == (42)) {
uint header = (uint)((8 + ((s.w_bits - 8) << 4)) << 8);uint level_flags = 0;if (((s.strategy) >= (2)) || ((s.level) < (2))) level_flags = (uint)(0); else if ((s.level) < (6)) level_flags = (uint)(1); else if ((s.level) == (6)) level_flags = (uint)(2); else level_flags = (uint)(3);header |= (uint)(level_flags << 6);if (s.strstart != 0) header |= (uint)(32);header += (uint)(31 - (header % 31));putShortMSB(s, (uint)(header));if (s.strstart != 0) {
putShortMSB(s, (uint)(strm.adler >> 16));putShortMSB(s, (uint)(strm.adler & 0xffff));}
strm.adler = (int)(adler32((int)(0L), null, (uint)(0)));s.status = (int)(113);flush_pending(strm);if (s.pending != 0) {
s.last_flush = (int)(-1);return (int)(0);}
}

			if ((s.status) == (57)) {
strm.adler = (int)(crc32((int)(0L), null, (uint)(0)));{
s.pending_buf[s.pending++] = ((byte)(31));}
{
s.pending_buf[s.pending++] = ((byte)(139));}
{
s.pending_buf[s.pending++] = ((byte)(8));}
if ((s.gzhead) == (null)) {
{
s.pending_buf[s.pending++] = ((byte)(0));}
{
s.pending_buf[s.pending++] = ((byte)(0));}
{
s.pending_buf[s.pending++] = ((byte)(0));}
{
s.pending_buf[s.pending++] = ((byte)(0));}
{
s.pending_buf[s.pending++] = ((byte)(0));}
{
s.pending_buf[s.pending++] = ((byte)((s.level) == (9)?2:(((s.strategy) >= (2)) || ((s.level) < (2))?4:0)));}
{
s.pending_buf[s.pending++] = ((byte)(10));}
s.status = (int)(113);flush_pending(strm);if (s.pending != 0) {
s.last_flush = (int)(-1);return (int)(0);}
}
 else {
{
s.pending_buf[s.pending++] = ((byte)(((s.gzhead->text) != 0?1:0) + ((s.gzhead->hcrc) != 0?2:0) + ((s.gzhead->extra) == (null)?0:4) + ((s.gzhead->name) == (null)?0:8) + ((s.gzhead->comment) == (null)?0:16)));}
{
s.pending_buf[s.pending++] = ((byte)(s.gzhead->time & 0xff));}
{
s.pending_buf[s.pending++] = ((byte)((s.gzhead->time >> 8) & 0xff));}
{
s.pending_buf[s.pending++] = ((byte)((s.gzhead->time >> 16) & 0xff));}
{
s.pending_buf[s.pending++] = ((byte)((s.gzhead->time >> 24) & 0xff));}
{
s.pending_buf[s.pending++] = ((byte)((s.level) == (9)?2:(((s.strategy) >= (2)) || ((s.level) < (2))?4:0)));}
{
s.pending_buf[s.pending++] = ((byte)(s.gzhead->os & 0xff));}
if (s.gzhead->extra != null) {
{
s.pending_buf[s.pending++] = ((byte)(s.gzhead->extra_len & 0xff));}
{
s.pending_buf[s.pending++] = ((byte)((s.gzhead->extra_len >> 8) & 0xff));}
}
if ((s.gzhead->hcrc) != 0) strm.adler = (int)(crc32((int)(strm.adler), s.pending_buf, (uint)(s.pending)));s.gzindex = (int)(0);s.status = (int)(69);}
}

			if ((s.status) == (69)) {
if (s.gzhead->extra != null) {
int beg = (int)(s.pending);uint left = (uint)((s.gzhead->extra_len & 0xffff) - s.gzindex);while ((s.pending + left) > (s.pending_buf_size)) {
uint copy = (uint)(s.pending_buf_size - s.pending);memcpy(s.pending_buf + s.pending, s.gzhead->extra + s.gzindex, (ulong)(copy));s.pending = (int)(s.pending_buf_size);do {
if (((s.gzhead->hcrc) != 0) && ((s.pending) > (beg))) strm.adler = (int)(crc32((int)(strm.adler), s.pending_buf + (beg), (uint)(s.pending - (beg))));}
 while ((0) != 0);s.gzindex += (int)(copy);flush_pending(strm);if (s.pending != 0) {
s.last_flush = (int)(-1);return (int)(0);}
beg = (int)(0);left -= (uint)(copy);}memcpy(s.pending_buf + s.pending, s.gzhead->extra + s.gzindex, (ulong)(left));s.pending += (int)(left);do {
if (((s.gzhead->hcrc) != 0) && ((s.pending) > (beg))) strm.adler = (int)(crc32((int)(strm.adler), s.pending_buf + (beg), (uint)(s.pending - (beg))));}
 while ((0) != 0);s.gzindex = (int)(0);}
s.status = (int)(73);}

			if ((s.status) == (73)) {
if (s.gzhead->name != null) {
int beg = (int)(s.pending);int val = 0;do {
if ((s.pending) == (s.pending_buf_size)) {
do {
if (((s.gzhead->hcrc) != 0) && ((s.pending) > (beg))) strm.adler = (int)(crc32((int)(strm.adler), s.pending_buf + (beg), (uint)(s.pending - (beg))));}
 while ((0) != 0);flush_pending(strm);if (s.pending != 0) {
s.last_flush = (int)(-1);return (int)(0);}
beg = (int)(0);}
val = (int)(s.gzhead->name[s.gzindex++]);{
s.pending_buf[s.pending++] = ((byte)(val));}
}
 while (val != 0);do {
if (((s.gzhead->hcrc) != 0) && ((s.pending) > (beg))) strm.adler = (int)(crc32((int)(strm.adler), s.pending_buf + (beg), (uint)(s.pending - (beg))));}
 while ((0) != 0);s.gzindex = (int)(0);}
s.status = (int)(91);}

			if ((s.status) == (91)) {
if (s.gzhead->comment != null) {
int beg = (int)(s.pending);int val = 0;do {
if ((s.pending) == (s.pending_buf_size)) {
do {
if (((s.gzhead->hcrc) != 0) && ((s.pending) > (beg))) strm.adler = (int)(crc32((int)(strm.adler), s.pending_buf + (beg), (uint)(s.pending - (beg))));}
 while ((0) != 0);flush_pending(strm);if (s.pending != 0) {
s.last_flush = (int)(-1);return (int)(0);}
beg = (int)(0);}
val = (int)(s.gzhead->comment[s.gzindex++]);{
s.pending_buf[s.pending++] = ((byte)(val));}
}
 while (val != 0);do {
if (((s.gzhead->hcrc) != 0) && ((s.pending) > (beg))) strm.adler = (int)(crc32((int)(strm.adler), s.pending_buf + (beg), (uint)(s.pending - (beg))));}
 while ((0) != 0);}
s.status = (int)(103);}

			if ((s.status) == (103)) {
if ((s.gzhead->hcrc) != 0) {
if ((s.pending + 2) > (s.pending_buf_size)) {
flush_pending(strm);if (s.pending != 0) {
s.last_flush = (int)(-1);return (int)(0);}
}
{
s.pending_buf[s.pending++] = ((byte)(strm.adler & 0xff));}
{
s.pending_buf[s.pending++] = ((byte)((strm.adler >> 8) & 0xff));}
strm.adler = (int)(crc32((int)(0L), null, (uint)(0)));}
s.status = (int)(113);flush_pending(strm);if (s.pending != 0) {
s.last_flush = (int)(-1);return (int)(0);}
}

			if (((strm.avail_in != 0) || (s.lookahead != 0)) || ((flush != 0) && (s.status != 666))) {
block_state bstate = 0;bstate = (block_state)((s.level) == (0)?deflate_stored(s, (int)(flush)):(s.strategy) == (2)?deflate_huff(s, (int)(flush)):(s.strategy) == (3)?deflate_rle(s, (int)(flush)):*(configuration_table[s.level].func)(s, (int)(flush)));if (((bstate) == (finish_started)) || ((bstate) == (finish_done))) {
s.status = (int)(666);}
if (((bstate) == (need_more)) || ((bstate) == (finish_started))) {
if ((strm.avail_out) == (0)) {
s.last_flush = (int)(-1);}
return (int)(0);}
if ((bstate) == (block_done)) {
if ((flush) == (1)) {
_tr_align(s);}
 else if (flush != 5) {
_tr_stored_block(s, (sbyte*)(0), (int)(0L), (int)(0));if ((flush) == (3)) {
s.head[s.hash_size - 1] = (ushort)(0);memset((byte*)(s.head), (int)(0), (ulong)((s.hash_size - 1) * sizeof((*s.head))));if ((s.lookahead) == (0)) {
s.strstart = (uint)(0);s.block_start = (int)(0L);s.insert = (uint)(0);}
}
}
flush_pending(strm);if ((strm.avail_out) == (0)) {
s.last_flush = (int)(-1);return (int)(0);}
}
}

			if (flush != 4) return (int)(0);
			if (s.wrap <= 0) return (int)(1);
			if ((s.wrap) == (2)) {
{
s.pending_buf[s.pending++] = ((byte)(strm.adler & 0xff));}
{
s.pending_buf[s.pending++] = ((byte)((strm.adler >> 8) & 0xff));}
{
s.pending_buf[s.pending++] = ((byte)((strm.adler >> 16) & 0xff));}
{
s.pending_buf[s.pending++] = ((byte)((strm.adler >> 24) & 0xff));}
{
s.pending_buf[s.pending++] = ((byte)(strm.total_in & 0xff));}
{
s.pending_buf[s.pending++] = ((byte)((strm.total_in >> 8) & 0xff));}
{
s.pending_buf[s.pending++] = ((byte)((strm.total_in >> 16) & 0xff));}
{
s.pending_buf[s.pending++] = ((byte)((strm.total_in >> 24) & 0xff));}
}
 else {
putShortMSB(s, (uint)(strm.adler >> 16));putShortMSB(s, (uint)(strm.adler & 0xffff));}

			flush_pending(strm);
			if ((s.wrap) > (0)) s.wrap = (int)(-s.wrap);
			return (int)(s.pending != 0?0:1);
		}

		public static int deflateEnd(z_stream_s strm)
		{
			int status = 0;
			if ((deflateStateCheck(strm)) != 0) return (int)(-2);
			status = (int)(strm.state.status);
			{
if ((strm.state.pending_buf) != null) strm.zfree(strm.opaque, (void *)(strm.state.pending_buf));}

			{
if ((strm.state.head) != null) strm.zfree(strm.opaque, (void *)(strm.state.head));}

			{
if ((strm.state.prev) != null) strm.zfree(strm.opaque, (void *)(strm.state.prev));}

			{
if ((strm.state.window) != null) strm.zfree(strm.opaque, (void *)(strm.state.window));}

			strm.zfree(strm.opaque, (void *)(strm.state));
			strm.state = null;
			return (int)((status) == (113)?(-3):0);
		}

		public static uint read_buf(z_stream_s strm, byte* buf, uint size)
		{
			uint len = (uint)(strm.avail_in);
			if ((len) > (size)) len = (uint)(size);
			if ((len) == (0)) return (uint)(0);
			strm.avail_in -= (uint)(len);
			memcpy(buf, strm.next_in, (ulong)(len));
			if ((strm.state.wrap) == (1)) {
strm.adler = (int)(adler32((int)(strm.adler), buf, (uint)(len)));}
 else if ((strm.state.wrap) == (2)) {
strm.adler = (int)(crc32((int)(strm.adler), buf, (uint)(len)));}

			strm.next_in += len;
			strm.total_in += (int)(len);
			return (uint)(len);
		}

		public static void lm_init(internal_state s)
		{
			s.window_size = (int)(2L * s.w_size);
			s.head[s.hash_size - 1] = (ushort)(0);
			memset((byte*)(s.head), (int)(0), (ulong)((s.hash_size - 1) * sizeof((*s.head))));
			s.max_lazy_match = (uint)(configuration_table[s.level].max_lazy);
			s.good_match = (uint)(configuration_table[s.level].good_length);
			s.nice_match = (int)(configuration_table[s.level].nice_length);
			s.max_chain_length = (uint)(configuration_table[s.level].max_chain);
			s.strstart = (uint)(0);
			s.block_start = (int)(0L);
			s.lookahead = (uint)(0);
			s.insert = (uint)(0);
			s.match_length = (uint)(s.prev_length = (uint)(3 - 1));
			s.match_available = (int)(0);
			s.ins_h = (uint)(0);
		}

		public static uint longest_match(internal_state s, uint cur_match)
		{
			uint chain_length = (uint)(s.max_chain_length);
			byte* scan = s.window + s.strstart;
			byte* match;
			int len = 0;
			int best_len = (int)(s.prev_length);
			int nice_match = (int)(s.nice_match);
			uint limit = (uint)((s.strstart) > (s.w_size - (258 + 3 + 1))?s.strstart - (s.w_size - (258 + 3 + 1)):0);
			ushort* prev = s.prev;
			uint wmask = (uint)(s.w_mask);
			byte* strend = s.window + s.strstart + 258;
			byte scan_end1 = (byte)(scan[best_len - 1]);
			byte scan_end = (byte)(scan[best_len]);
			if ((s.prev_length) >= (s.good_match)) {
chain_length >>= 2;}

			if (((uint)(nice_match)) > (s.lookahead)) nice_match = ((int)(s.lookahead));
			do {
match = s.window + cur_match;if ((((match[best_len] != scan_end) || (match[best_len - 1] != scan_end1)) || (*match != *scan)) || (*++match != scan[1])) continue;scan += 2 , match++;do {
}
 while ((((((((((*++scan) == (*++match)) && ((*++scan) == (*++match))) && ((*++scan) == (*++match))) && ((*++scan) == (*++match))) && ((*++scan) == (*++match))) && ((*++scan) == (*++match))) && ((*++scan) == (*++match))) && ((*++scan) == (*++match))) && ((scan) < (strend)));len = (int)(258 - (int)(strend - scan));scan = strend - 258;if ((len) > (best_len)) {
s.match_start = (uint)(cur_match);best_len = (int)(len);if ((len) >= (nice_match)) break;scan_end1 = (byte)(scan[best_len - 1]);scan_end = (byte)(scan[best_len]);}
}
 while (((cur_match = (uint)(prev[cur_match & wmask])) > (limit)) && (--chain_length != 0));
			if ((uint)(best_len) <= s.lookahead) return (uint)(best_len);
			return (uint)(s.lookahead);
		}

		public static void fill_window(internal_state s)
		{
			uint n = 0;
			uint more = 0;
			uint wsize = (uint)(s.w_size);
			do {
more = ((uint)(s.window_size - (int)(s.lookahead) - (int)(s.strstart)));if (sizeof(int) <= 2) {
if ((((more) == (0)) && ((s.strstart) == (0))) && ((s.lookahead) == (0))) {
more = (uint)(wsize);}
 else if ((more) == ((uint)(-1))) {
more--;}
}
if ((s.strstart) >= (wsize + (s.w_size - (258 + 3 + 1)))) {
memcpy(s.window, s.window + wsize, (ulong)(wsize - more));s.match_start -= (uint)(wsize);s.strstart -= (uint)(wsize);s.block_start -= ((int)(wsize));slide_hash(s);more += (uint)(wsize);}
if ((s.strm.avail_in) == (0)) break;n = (uint)(read_buf(s.strm, s.window + s.strstart + s.lookahead, (uint)(more)));s.lookahead += (uint)(n);if ((s.lookahead + s.insert) >= (3)) {
uint str = (uint)(s.strstart - s.insert);s.ins_h = (uint)(s.window[str]);(s.ins_h = (uint)((((s.ins_h) << s.hash_shift) ^ (s.window[str + 1])) & s.hash_mask));while ((s.insert) != 0) {
(s.ins_h = (uint)((((s.ins_h) << s.hash_shift) ^ (s.window[str + 3 - 1])) & s.hash_mask));s.prev[str & s.w_mask] = (ushort)(s.head[s.ins_h]);s.head[s.ins_h] = ((ushort)(str));str++;s.insert--;if ((s.lookahead + s.insert) < (3)) break;}}
}
 while (((s.lookahead) < (258 + 3 + 1)) && (s.strm.avail_in != 0));
			if ((s.high_water) < (s.window_size)) {
int curr = (int)(s.strstart + (int)(s.lookahead));int init = 0;if ((s.high_water) < (curr)) {
init = (int)(s.window_size - curr);if ((init) > (258)) init = (int)(258);memset(s.window + curr, (int)(0), (ulong)((uint)(init)));s.high_water = (int)(curr + init);}
 else if ((s.high_water) < (curr + 258)) {
init = (int)(curr + 258 - s.high_water);if ((init) > (s.window_size - s.high_water)) init = (int)(s.window_size - s.high_water);memset(s.window + s.high_water, (int)(0), (ulong)((uint)(init)));s.high_water += (int)(init);}
}

		}

		public static block_state deflate_stored(internal_state s, int flush)
		{
			uint min_block = (uint)((s.pending_buf_size - 5) > (s.w_size)?(s.w_size):(s.pending_buf_size - 5));
			uint len = 0;uint left = 0;uint have = 0;uint last = (uint)(0);
			uint used = (uint)(s.strm.avail_in);
			do {
len = (uint)(65535);have = (uint)((s.bi_valid + 42) >> 3);if ((s.strm.avail_out) < (have)) break;have = (uint)(s.strm.avail_out - have);left = (uint)(s.strstart - s.block_start);if ((len) > ((int)(left) + s.strm.avail_in)) len = (uint)(left + s.strm.avail_in);if ((len) > (have)) len = (uint)(have);if (((len) < (min_block)) && (((((len) == (0)) && (flush != 4)) || ((flush) == (0))) || (len != left + s.strm.avail_in))) break;last = (uint)(((flush) == (4)) && ((len) == (left + s.strm.avail_in))?1:0);_tr_stored_block(s, (sbyte*)(0), (int)(0L), (int)(last));s.pending_buf[s.pending - 4] = (byte)(len);s.pending_buf[s.pending - 3] = (byte)(len >> 8);s.pending_buf[s.pending - 2] = (byte)(~len);s.pending_buf[s.pending - 1] = (byte)(~len >> 8);flush_pending(s.strm);if ((left) != 0) {
if ((left) > (len)) left = (uint)(len);memcpy(s.strm.next_out, s.window + s.block_start, (ulong)(left));s.strm.next_out += left;s.strm.avail_out -= (uint)(left);s.strm.total_out += (int)(left);s.block_start += (int)(left);len -= (uint)(left);}
if ((len) != 0) {
read_buf(s.strm, s.strm.next_out, (uint)(len));s.strm.next_out += len;s.strm.avail_out -= (uint)(len);s.strm.total_out += (int)(len);}
}
 while ((last) == (0));
			used -= (uint)(s.strm.avail_in);
			if ((used) != 0) {
if ((used) >= (s.w_size)) {
s.matches = (uint)(2);memcpy(s.window, s.strm.next_in - s.w_size, (ulong)(s.w_size));s.strstart = (uint)(s.w_size);}
 else {
if (s.window_size - s.strstart <= used) {
s.strstart -= (uint)(s.w_size);memcpy(s.window, s.window + s.w_size, (ulong)(s.strstart));if ((s.matches) < (2)) s.matches++;}
memcpy(s.window + s.strstart, s.strm.next_in - used, (ulong)(used));s.strstart += (uint)(used);}
s.block_start = (int)(s.strstart);s.insert += (uint)((used) > (s.w_size - s.insert)?(s.w_size - s.insert):(used));}

			if ((s.high_water) < (s.strstart)) s.high_water = (int)(s.strstart);
			if ((last) != 0) return (block_state)(finish_done);
			if ((((flush != 0) && (flush != 4)) && ((s.strm.avail_in) == (0))) && (((int)(s.strstart)) == (s.block_start))) return (block_state)(block_done);
			have = (uint)(s.window_size - s.strstart - 1);
			if (((s.strm.avail_in) > (have)) && ((s.block_start) >= ((int)(s.w_size)))) {
s.block_start -= (int)(s.w_size);s.strstart -= (uint)(s.w_size);memcpy(s.window, s.window + s.w_size, (ulong)(s.strstart));if ((s.matches) < (2)) s.matches++;have += (uint)(s.w_size);}

			if ((have) > (s.strm.avail_in)) have = (uint)(s.strm.avail_in);
			if ((have) != 0) {
read_buf(s.strm, s.window + s.strstart, (uint)(have));s.strstart += (uint)(have);}

			if ((s.high_water) < (s.strstart)) s.high_water = (int)(s.strstart);
			have = (uint)((s.bi_valid + 42) >> 3);
			have = (uint)((s.pending_buf_size - have) > (65535)?(65535):(s.pending_buf_size - have));
			min_block = (uint)((have) > (s.w_size)?(s.w_size):(have));
			left = (uint)(s.strstart - s.block_start);
			if (((left) >= (min_block)) || ((((((left) != 0) || ((flush) == (4))) && (flush != 0)) && ((s.strm.avail_in) == (0))) && (left <= have))) {
len = (uint)((left) > (have)?(have):(left));last = (uint)((((flush) == (4)) && ((s.strm.avail_in) == (0))) && ((len) == (left))?1:0);_tr_stored_block(s, (sbyte*)(s.window) + s.block_start, (int)(len), (int)(last));s.block_start += (int)(len);flush_pending(s.strm);}

			return (block_state)((last) != 0?finish_started:need_more);
		}

		public static block_state deflate_fast(internal_state s, int flush)
		{
			uint hash_head = 0;
			int bflush = 0;
			for (; ; ) {
if ((s.lookahead) < (258 + 3 + 1)) {
fill_window(s);if (((s.lookahead) < (258 + 3 + 1)) && ((flush) == (0))) {
return (block_state)(need_more);}
if ((s.lookahead) == (0)) break;}
hash_head = (uint)(0);if ((s.lookahead) >= (3)) {
((s.ins_h = (uint)((((s.ins_h) << s.hash_shift) ^ (s.window[(s.strstart) + (3 - 1)])) & s.hash_mask)) , hash_head = (uint)(s.prev[(s.strstart) & s.w_mask] = (ushort)(s.head[s.ins_h])) , s.head[s.ins_h] = ((ushort)(s.strstart)));}
if ((hash_head != 0) && (s.strstart - hash_head <= (s.w_size - (258 + 3 + 1)))) {
s.match_length = (uint)(longest_match(s, (uint)(hash_head)));}
if ((s.match_length) >= (3)) {
{
byte len = (byte)(s.match_length - 3);ushort dist = (ushort)(s.strstart - s.match_start);s.d_buf[s.last_lit] = (ushort)(dist);s.l_buf[s.last_lit++] = (byte)(len);dist--;s.dyn_ltree[_length_code[len] + 256 + 1].fc.freq++;s.dyn_dtree[((dist) < (256)?_dist_code[dist]:_dist_code[256 + ((dist) >> 7)])].fc.freq++;bflush = (int)((s.last_lit) == (s.lit_bufsize - 1)?1:0);}
s.lookahead -= (uint)(s.match_length);if ((s.match_length <= s.max_lazy_match) && ((s.lookahead) >= (3))) {
s.match_length--;do {
s.strstart++;((s.ins_h = (uint)((((s.ins_h) << s.hash_shift) ^ (s.window[(s.strstart) + (3 - 1)])) & s.hash_mask)) , hash_head = (uint)(s.prev[(s.strstart) & s.w_mask] = (ushort)(s.head[s.ins_h])) , s.head[s.ins_h] = ((ushort)(s.strstart)));}
 while (--s.match_length != 0);s.strstart++;}
 else {
s.strstart += (uint)(s.match_length);s.match_length = (uint)(0);s.ins_h = (uint)(s.window[s.strstart]);(s.ins_h = (uint)((((s.ins_h) << s.hash_shift) ^ (s.window[s.strstart + 1])) & s.hash_mask));}
}
 else {
{
byte cc = (byte)(s.window[s.strstart]);s.d_buf[s.last_lit] = (ushort)(0);s.l_buf[s.last_lit++] = (byte)(cc);s.dyn_ltree[cc].fc.freq++;bflush = (int)((s.last_lit) == (s.lit_bufsize - 1)?1:0);}
s.lookahead--;s.strstart++;}
if ((bflush) != 0) {
{
_tr_flush_block(s, ((s.block_start) >= (0L)?(sbyte*)(&s.window[(uint)(s.block_start)]):(sbyte*)(0)), (int)((int)(s.strstart) - s.block_start), (int)(0));s.block_start = (int)(s.strstart);flush_pending(s.strm);}
if ((s.strm.avail_out) == (0)) return (block_state)(need_more);}
}
			s.insert = (uint)((s.strstart) < (3 - 1)?s.strstart:3 - 1);
			if ((flush) == (4)) {
{
{
_tr_flush_block(s, ((s.block_start) >= (0L)?(sbyte*)(&s.window[(uint)(s.block_start)]):(sbyte*)(0)), (int)((int)(s.strstart) - s.block_start), (int)(1));s.block_start = (int)(s.strstart);flush_pending(s.strm);}
if ((s.strm.avail_out) == (0)) return (block_state)(finished_started);}
return (block_state)(finish_done);}

			if ((s.last_lit) != 0) {
{
_tr_flush_block(s, ((s.block_start) >= (0L)?(sbyte*)(&s.window[(uint)(s.block_start)]):(sbyte*)(0)), (int)((int)(s.strstart) - s.block_start), (int)(0));s.block_start = (int)(s.strstart);flush_pending(s.strm);}
if ((s.strm.avail_out) == (0)) return (block_state)(need_more);}

			return (block_state)(block_done);
		}

		public static block_state deflate_slow(internal_state s, int flush)
		{
			uint hash_head = 0;
			int bflush = 0;
			for (; ; ) {
if ((s.lookahead) < (258 + 3 + 1)) {
fill_window(s);if (((s.lookahead) < (258 + 3 + 1)) && ((flush) == (0))) {
return (block_state)(need_more);}
if ((s.lookahead) == (0)) break;}
hash_head = (uint)(0);if ((s.lookahead) >= (3)) {
((s.ins_h = (uint)((((s.ins_h) << s.hash_shift) ^ (s.window[(s.strstart) + (3 - 1)])) & s.hash_mask)) , hash_head = (uint)(s.prev[(s.strstart) & s.w_mask] = (ushort)(s.head[s.ins_h])) , s.head[s.ins_h] = ((ushort)(s.strstart)));}
s.prev_length = (uint)(s.match_length) , s.prev_match = (uint)(s.match_start);s.match_length = (uint)(3 - 1);if (((hash_head != 0) && ((s.prev_length) < (s.max_lazy_match))) && (s.strstart - hash_head <= (s.w_size - (258 + 3 + 1)))) {
s.match_length = (uint)(longest_match(s, (uint)(hash_head)));if ((s.match_length <= 5) && (((s.strategy) == (1)) || (((s.match_length) == (3)) && ((s.strstart - s.match_start) > (4096))))) {
s.match_length = (uint)(3 - 1);}
}
if (((s.prev_length) >= (3)) && (s.match_length <= s.prev_length)) {
uint max_insert = (uint)(s.strstart + s.lookahead - 3);{
byte len = (byte)(s.prev_length - 3);ushort dist = (ushort)(s.strstart - 1 - s.prev_match);s.d_buf[s.last_lit] = (ushort)(dist);s.l_buf[s.last_lit++] = (byte)(len);dist--;s.dyn_ltree[_length_code[len] + 256 + 1].fc.freq++;s.dyn_dtree[((dist) < (256)?_dist_code[dist]:_dist_code[256 + ((dist) >> 7)])].fc.freq++;bflush = (int)((s.last_lit) == (s.lit_bufsize - 1)?1:0);}
s.lookahead -= (uint)(s.prev_length - 1);s.prev_length -= (uint)(2);do {
if (++s.strstart <= max_insert) {
((s.ins_h = (uint)((((s.ins_h) << s.hash_shift) ^ (s.window[(s.strstart) + (3 - 1)])) & s.hash_mask)) , hash_head = (uint)(s.prev[(s.strstart) & s.w_mask] = (ushort)(s.head[s.ins_h])) , s.head[s.ins_h] = ((ushort)(s.strstart)));}
}
 while (--s.prev_length != 0);s.match_available = (int)(0);s.match_length = (uint)(3 - 1);s.strstart++;if ((bflush) != 0) {
{
_tr_flush_block(s, ((s.block_start) >= (0L)?(sbyte*)(&s.window[(uint)(s.block_start)]):(sbyte*)(0)), (int)((int)(s.strstart) - s.block_start), (int)(0));s.block_start = (int)(s.strstart);flush_pending(s.strm);}
if ((s.strm.avail_out) == (0)) return (block_state)(need_more);}
}
 else if ((s.match_available) != 0) {
{
byte cc = (byte)(s.window[s.strstart - 1]);s.d_buf[s.last_lit] = (ushort)(0);s.l_buf[s.last_lit++] = (byte)(cc);s.dyn_ltree[cc].fc.freq++;bflush = (int)((s.last_lit) == (s.lit_bufsize - 1)?1:0);}
if ((bflush) != 0) {
{
_tr_flush_block(s, ((s.block_start) >= (0L)?(sbyte*)(&s.window[(uint)(s.block_start)]):(sbyte*)(0)), (int)((int)(s.strstart) - s.block_start), (int)(0));s.block_start = (int)(s.strstart);flush_pending(s.strm);}
}
s.strstart++;s.lookahead--;if ((s.strm.avail_out) == (0)) return (block_state)(need_more);}
 else {
s.match_available = (int)(1);s.strstart++;s.lookahead--;}
}
			if ((s.match_available) != 0) {
{
byte cc = (byte)(s.window[s.strstart - 1]);s.d_buf[s.last_lit] = (ushort)(0);s.l_buf[s.last_lit++] = (byte)(cc);s.dyn_ltree[cc].fc.freq++;bflush = (int)((s.last_lit) == (s.lit_bufsize - 1)?1:0);}
s.match_available = (int)(0);}

			s.insert = (uint)((s.strstart) < (3 - 1)?s.strstart:3 - 1);
			if ((flush) == (4)) {
{
{
_tr_flush_block(s, ((s.block_start) >= (0L)?(sbyte*)(&s.window[(uint)(s.block_start)]):(sbyte*)(0)), (int)((int)(s.strstart) - s.block_start), (int)(1));s.block_start = (int)(s.strstart);flush_pending(s.strm);}
if ((s.strm.avail_out) == (0)) return (block_state)(finished_started);}
return (block_state)(finish_done);}

			if ((s.last_lit) != 0) {
{
_tr_flush_block(s, ((s.block_start) >= (0L)?(sbyte*)(&s.window[(uint)(s.block_start)]):(sbyte*)(0)), (int)((int)(s.strstart) - s.block_start), (int)(0));s.block_start = (int)(s.strstart);flush_pending(s.strm);}
if ((s.strm.avail_out) == (0)) return (block_state)(need_more);}

			return (block_state)(block_done);
		}

		public static block_state deflate_rle(internal_state s, int flush)
		{
			int bflush = 0;
			uint prev = 0;
			byte* scan;byte* strend;
			for (; ; ) {
if (s.lookahead <= 258) {
fill_window(s);if ((s.lookahead <= 258) && ((flush) == (0))) {
return (block_state)(need_more);}
if ((s.lookahead) == (0)) break;}
s.match_length = (uint)(0);if (((s.lookahead) >= (3)) && ((s.strstart) > (0))) {
scan = s.window + s.strstart - 1;prev = (uint)(*scan);if ((((prev) == (*++scan)) && ((prev) == (*++scan))) && ((prev) == (*++scan))) {
strend = s.window + s.strstart + 258;do {
}
 while ((((((((((prev) == (*++scan)) && ((prev) == (*++scan))) && ((prev) == (*++scan))) && ((prev) == (*++scan))) && ((prev) == (*++scan))) && ((prev) == (*++scan))) && ((prev) == (*++scan))) && ((prev) == (*++scan))) && ((scan) < (strend)));s.match_length = (uint)(258 - (uint)(strend - scan));if ((s.match_length) > (s.lookahead)) s.match_length = (uint)(s.lookahead);}
}
if ((s.match_length) >= (3)) {
{
byte len = (byte)(s.match_length - 3);ushort dist = (ushort)(1);s.d_buf[s.last_lit] = (ushort)(dist);s.l_buf[s.last_lit++] = (byte)(len);dist--;s.dyn_ltree[_length_code[len] + 256 + 1].fc.freq++;s.dyn_dtree[((dist) < (256)?_dist_code[dist]:_dist_code[256 + ((dist) >> 7)])].fc.freq++;bflush = (int)((s.last_lit) == (s.lit_bufsize - 1)?1:0);}
s.lookahead -= (uint)(s.match_length);s.strstart += (uint)(s.match_length);s.match_length = (uint)(0);}
 else {
{
byte cc = (byte)(s.window[s.strstart]);s.d_buf[s.last_lit] = (ushort)(0);s.l_buf[s.last_lit++] = (byte)(cc);s.dyn_ltree[cc].fc.freq++;bflush = (int)((s.last_lit) == (s.lit_bufsize - 1)?1:0);}
s.lookahead--;s.strstart++;}
if ((bflush) != 0) {
{
_tr_flush_block(s, ((s.block_start) >= (0L)?(sbyte*)(&s.window[(uint)(s.block_start)]):(sbyte*)(0)), (int)((int)(s.strstart) - s.block_start), (int)(0));s.block_start = (int)(s.strstart);flush_pending(s.strm);}
if ((s.strm.avail_out) == (0)) return (block_state)(need_more);}
}
			s.insert = (uint)(0);
			if ((flush) == (4)) {
{
{
_tr_flush_block(s, ((s.block_start) >= (0L)?(sbyte*)(&s.window[(uint)(s.block_start)]):(sbyte*)(0)), (int)((int)(s.strstart) - s.block_start), (int)(1));s.block_start = (int)(s.strstart);flush_pending(s.strm);}
if ((s.strm.avail_out) == (0)) return (block_state)(finished_started);}
return (block_state)(finish_done);}

			if ((s.last_lit) != 0) {
{
_tr_flush_block(s, ((s.block_start) >= (0L)?(sbyte*)(&s.window[(uint)(s.block_start)]):(sbyte*)(0)), (int)((int)(s.strstart) - s.block_start), (int)(0));s.block_start = (int)(s.strstart);flush_pending(s.strm);}
if ((s.strm.avail_out) == (0)) return (block_state)(need_more);}

			return (block_state)(block_done);
		}

		public static block_state deflate_huff(internal_state s, int flush)
		{
			int bflush = 0;
			for (; ; ) {
if ((s.lookahead) == (0)) {
fill_window(s);if ((s.lookahead) == (0)) {
if ((flush) == (0)) return (block_state)(need_more);break;}
}
s.match_length = (uint)(0);{
byte cc = (byte)(s.window[s.strstart]);s.d_buf[s.last_lit] = (ushort)(0);s.l_buf[s.last_lit++] = (byte)(cc);s.dyn_ltree[cc].fc.freq++;bflush = (int)((s.last_lit) == (s.lit_bufsize - 1)?1:0);}
s.lookahead--;s.strstart++;if ((bflush) != 0) {
{
_tr_flush_block(s, ((s.block_start) >= (0L)?(sbyte*)(&s.window[(uint)(s.block_start)]):(sbyte*)(0)), (int)((int)(s.strstart) - s.block_start), (int)(0));s.block_start = (int)(s.strstart);flush_pending(s.strm);}
if ((s.strm.avail_out) == (0)) return (block_state)(need_more);}
}
			s.insert = (uint)(0);
			if ((flush) == (4)) {
{
{
_tr_flush_block(s, ((s.block_start) >= (0L)?(sbyte*)(&s.window[(uint)(s.block_start)]):(sbyte*)(0)), (int)((int)(s.strstart) - s.block_start), (int)(1));s.block_start = (int)(s.strstart);flush_pending(s.strm);}
if ((s.strm.avail_out) == (0)) return (block_state)(finished_started);}
return (block_state)(finish_done);}

			if ((s.last_lit) != 0) {
{
_tr_flush_block(s, ((s.block_start) >= (0L)?(sbyte*)(&s.window[(uint)(s.block_start)]):(sbyte*)(0)), (int)((int)(s.strstart) - s.block_start), (int)(0));s.block_start = (int)(s.strstart);flush_pending(s.strm);}
if ((s.strm.avail_out) == (0)) return (block_state)(need_more);}

			return (block_state)(block_done);
		}

}
}