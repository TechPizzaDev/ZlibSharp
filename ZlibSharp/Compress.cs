// Generated by Sichem at 2020-09-30 18:30:48

using System;
using System.Runtime.InteropServices;
using static CRuntime;

namespace ZlibSharp
{
	unsafe class Compress
	{
		[StructLayout(LayoutKind.Sequential)]
		public class z_stream_s
	{
		public byte* next_in;
		public uint avail_in;
		public int total_in;
		public byte* next_out;
		public uint avail_out;
		public int total_out;
		public string msg;
		public internal_state state;
		public zalloc_delegate zalloc;
		public zfree_delegate zfree;
		public void * opaque;
		public int data_type;
		public int adler;
		public int reserved;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct gz_header_s
	{
		public int text;
		public int time;
		public int xflags;
		public int os;
		public byte* extra;
		public uint extra_len;
		public uint extra_max;
		public byte* name;
		public uint name_max;
		public byte* comment;
		public uint comm_max;
		public int hcrc;
		public int done;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct gzFile_s
	{
		public uint have;
		public byte* next;
		public long pos;
		}
		public static int compress2(byte* dest, int* destLen, byte* source, int sourceLen, int level)
		{
			z_stream_s stream = new z_stream_s();
			int err = 0;
			uint max = (uint)(-1);
			int left = 0;
			left = (int)(*destLen);
			*destLen = (int)(0);
			stream.zalloc = (zalloc_delegate)(0);
			stream.zfree = (zfree_delegate)(0);
			stream.opaque = (void *)(0);
			err = (int)(deflateInit_((&stream), (int)(level), "1.2.11", (int)(sizeof(z_stream_s))));
			if (err != 0) return (int)(err);
			stream.next_out = dest;
			stream.avail_out = (uint)(0);
			stream.next_in = source;
			stream.avail_in = (uint)(0);
			do {
if ((stream.avail_out) == (0)) {
stream.avail_out = (uint)((left) > ((int)(max))?max:(uint)(left));left -= (int)(stream.avail_out);}
if ((stream.avail_in) == (0)) {
stream.avail_in = (uint)((sourceLen) > ((int)(max))?max:(uint)(sourceLen));sourceLen -= (int)(stream.avail_in);}
err = (int)(deflate(&stream, (int)((sourceLen) != 0?0:4)));}
 while ((err) == (0));
			*destLen = (int)(stream.total_out);
			deflateEnd(&stream);
			return (int)((err) == (1)?0:err);
		}

		public static int compress(byte* dest, int* destLen, byte* source, int sourceLen)
		{
			return (int)(compress2(dest, destLen, source, (int)(sourceLen), (int)(-1)));
		}

		public static int compressBound(int sourceLen)
		{
			return (int)(sourceLen + (sourceLen >> 12) + (sourceLen >> 14) + (sourceLen >> 25) + 13);
		}

}
}