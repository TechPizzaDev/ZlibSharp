// Generated by Sichem at 2020-09-30 18:30:56

using System;
using System.Runtime.InteropServices;
using static CRuntime;

namespace ZlibSharp
{
	unsafe class Uncompress
	{
		[StructLayout(LayoutKind.Sequential)]
		public class z_stream_s
	{
		public byte* next_in;
		public uint avail_in;
		public int total_in;
		public byte* next_out;
		public uint avail_out;
		public int total_out;
		public string msg;
		public internal_state state;
		public zalloc_delegate zalloc;
		public zfree_delegate zfree;
		public void * opaque;
		public int data_type;
		public int adler;
		public int reserved;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct gz_header_s
	{
		public int text;
		public int time;
		public int xflags;
		public int os;
		public byte* extra;
		public uint extra_len;
		public uint extra_max;
		public byte* name;
		public uint name_max;
		public byte* comment;
		public uint comm_max;
		public int hcrc;
		public int done;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct gzFile_s
	{
		public uint have;
		public byte* next;
		public long pos;
		}
		public static int uncompress2(byte* dest, int* destLen, byte* source, int* sourceLen)
		{
			z_stream_s stream = new z_stream_s();
			int err = 0;
			uint max = (uint)-1;
			int len = 0;int left = 0;
			byte* buf = stackalloc byte[1];
			len = *sourceLen;
			if ((*destLen) != 0) {
left = *destLen;
                *destLen = 0;
            }
 else {
left = 1;
                dest = buf;}

			stream.next_in = source;
			stream.avail_in = 0;
			stream.zalloc = (zalloc_delegate)0;
			stream.zfree = (zfree_delegate)0;
			stream.opaque = (void *)0;
			err = (int)inflateInit_(&stream, "1.2.11", sizeof(z_stream_s));
			if (err != 0) return err;
			stream.next_out = dest;
			stream.avail_out = 0;
			do {
if (stream.avail_out == 0) {
stream.avail_out = left > ((int)max) ? max : (uint)left;
                    left -= (int)stream.avail_out;}
if (stream.avail_in == 0) {
stream.avail_in = len > ((int)max) ? max : (uint)len;
                    len -= (int)stream.avail_in;}
err = (int)inflate(&stream, 0);}
 while (err == 0);
			*sourceLen -= (int)(len + stream.avail_in);
			if (dest != buf) *destLen = stream.total_out; else if ((stream.total_out != 0) && (err == (-5))) left = 1;
			inflateEnd(&stream);
			return err == 1 ? 0 : err == 2 ? (-3) : (err == (-5)) && (left + stream.avail_out) ? (-3) : err;
		}

		public static int uncompress(byte* dest, int* destLen, byte* source, int sourceLen)
		{
			return uncompress2(dest, destLen, source, &sourceLen);
		}

}
}