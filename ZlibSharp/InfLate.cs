// Generated by Sichem at 2020-09-30 18:30:54

using System;
using System.Runtime.InteropServices;
using static CRuntime;

namespace ZlibSharp
{
	unsafe class InfLate
	{
		public const int CODES = 0;
		public const int LENS = 1;
		public const int DISTS = 2;
		public const int HEAD = 16180;
		public const int FLAGS = 16181;
		public const int TIME = 16182;
		public const int OS = 16183;
		public const int EXLEN = 16184;
		public const int EXTRA = 16185;
		public const int NAME = 16186;
		public const int COMMENT = 16187;
		public const int HCRC = 16188;
		public const int DICTID = 16189;
		public const int DICT = 16190;
		public const int TYPE = 16191;
		public const int TYPEDO = 16192;
		public const int STORED = 16193;
		public const int COPY_ = 16194;
		public const int COPY = 16195;
		public const int TABLE = 16196;
		public const int LENLENS = 16197;
		public const int CODELENS = 16198;
		public const int LEN_ = 16199;
		public const int LEN = 16200;
		public const int LENEXT = 16201;
		public const int DIST = 16202;
		public const int DISTEXT = 16203;
		public const int MATCH = 16204;
		public const int LIT = 16205;
		public const int CHECK = 16206;
		public const int LENGTH = 16207;
		public const int DONE = 16208;
		public const int BAD = 16209;
		public const int MEM = 16210;
		public const int SYNC = 16211;
		public static sbyte*[] z_errmsg = new sbyte[10];
		[StructLayout(LayoutKind.Sequential)]
		public class z_stream_s
	{
		public byte* next_in;
		public uint avail_in;
		public int total_in;
		public byte* next_out;
		public uint avail_out;
		public int total_out;
		public string msg;
		public internal_state state;
		public zalloc_delegate zalloc;
		public zfree_delegate zfree;
		public void * opaque;
		public int data_type;
		public int adler;
		public int reserved;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct gz_header_s
	{
		public int text;
		public int time;
		public int xflags;
		public int os;
		public byte* extra;
		public uint extra_len;
		public uint extra_max;
		public byte* name;
		public uint name_max;
		public byte* comment;
		public uint comm_max;
		public int hcrc;
		public int done;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct gzFile_s
	{
		public uint have;
		public byte* next;
		public long pos;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct code
	{
		public byte op;
		public byte bits;
		public ushort val;
		}
		[StructLayout(LayoutKind.Sequential)]
		public class inflate_state
	{
		public z_stream_s strm;
		public inflate_mode mode;
		public int last;
		public int wrap;
		public int havedict;
		public int flags;
		public uint dmax;
		public int check;
		public int total;
		public gz_header_s* head;
		public uint wbits;
		public uint wsize;
		public uint whave;
		public uint wnext;
		public byte* window;
		public int hold;
		public uint bits;
		public uint length;
		public uint offset;
		public uint extra;
		public code* lencode;
		public code* distcode;
		public uint lenbits;
		public uint distbits;
		public uint ncode;
		public uint nlen;
		public uint ndist;
		public uint have;
		public code* next;
		public fixed ushort lens[320];
		public fixed ushort work[288];
		public code[] codes;
		public int sane;
		public int back;
		public uint was;
		}
		public static int inflateStateCheck(z_stream_s strm)
		{
			inflate_state state;
			if ((((strm) == (null)) || (strm.zalloc == ((zalloc_delegate)(0)))) || (strm.zfree == ((zfree_delegate)(0)))) return (int)(1);
			state = (inflate_state)(strm.state);
			if (((((state) == (null)) || (state->strm != strm)) || ((state->mode) < (HEAD))) || ((state->mode) > (SYNC))) return (int)(1);
			return (int)(0);
		}

		public static int inflateResetKeep(z_stream_s strm)
		{
			inflate_state state;
			if ((inflateStateCheck(strm)) != 0) return (int)(-2);
			state = (inflate_state)(strm.state);
			strm.total_in = (int)(strm.total_out = (int)(state->total = (int)(0)));
			strm.msg = null;
			if ((state->wrap) != 0) strm.adler = (int)(state->wrap & 1);
			state->mode = (inflate_mode)(HEAD);
			state->last = (int)(0);
			state->havedict = (int)(0);
			state->dmax = (uint)(32768U);
			state->head = null;
			state->hold = (int)(0);
			state->bits = (uint)(0);
			state->lencode = state->distcode = state->next = state->codes;
			state->sane = (int)(1);
			state->back = (int)(-1);
			return (int)(0);
		}

		public static int inflateReset(z_stream_s strm)
		{
			inflate_state state;
			if ((inflateStateCheck(strm)) != 0) return (int)(-2);
			state = (inflate_state)(strm.state);
			state->wsize = (uint)(0);
			state->whave = (uint)(0);
			state->wnext = (uint)(0);
			return (int)(inflateResetKeep(strm));
		}

		public static int inflateReset2(z_stream_s strm, int windowBits)
		{
			int wrap = 0;
			inflate_state state;
			if ((inflateStateCheck(strm)) != 0) return (int)(-2);
			state = (inflate_state)(strm.state);
			if ((windowBits) < (0)) {
wrap = (int)(0);windowBits = (int)(-windowBits);}
 else {
wrap = (int)((windowBits >> 4) + 5);if ((windowBits) < (48)) windowBits &= (int)(15);}

			if (((windowBits) != 0) && (((windowBits) < (8)) || ((windowBits) > (15)))) return (int)(-2);
			if ((state->window != null) && (state->wbits != (uint)(windowBits))) {
strm.zfree(strm.opaque, (void *)(state->window));state->window = null;}

			state->wrap = (int)(wrap);
			state->wbits = ((uint)(windowBits));
			return (int)(inflateReset(strm));
		}

		public static int inflateInit2_(z_stream_s strm, int windowBits, sbyte* version, int stream_size)
		{
			int ret = 0;
			inflate_state state;
			if ((((version) == (null)) || (version[0] != "1.2.11"[0])) || (stream_size != (int)(sizeof(z_stream_s)))) return (int)(-6);
			if ((strm) == (null)) return (int)(-2);
			strm.msg = null;
			if (strm.zalloc == ((zalloc_delegate)(0))) {
strm.zalloc = zcalloc;strm.opaque = (void *)(0);}

			if (strm.zfree == ((zfree_delegate)(0))) strm.zfree = zcfree;
			state = (inflate_state)(strm.zalloc(strm.opaque, (uint)(1), (uint)(sizeof(inflate_state))));
			if ((state) == (null)) return (int)(-4);
			strm.state = (internal_state)(state);
			state->strm = strm;
			state->window = null;
			state->mode = (inflate_mode)(HEAD);
			ret = (int)(inflateReset2(strm, (int)(windowBits)));
			if (ret != 0) {
strm.zfree(strm.opaque, (void *)(state));strm.state = null;}

			return (int)(ret);
		}

		public static int inflateInit_(z_stream_s strm, sbyte* version, int stream_size)
		{
			return (int)(inflateInit2_(strm, (int)(15), version, (int)(stream_size)));
		}

		public static int inflatePrime(z_stream_s strm, int bits, int value)
		{
			inflate_state state;
			if ((inflateStateCheck(strm)) != 0) return (int)(-2);
			state = (inflate_state)(strm.state);
			if ((bits) < (0)) {
state->hold = (int)(0);state->bits = (uint)(0);return (int)(0);}

			if (((bits) > (16)) || ((state->bits + (uint)(bits)) > (32))) return (int)(-2);
			value &= (int)((1L << bits) - 1);
			state->hold += (int)((uint)(value) << state->bits);
			state->bits += ((uint)(bits));
			return (int)(0);
		}

		public static void fixedtables(inflate_state state)
		{
			code* lenfix = stackalloc code[512];
lenfix[0] = (code)({ 96, 7, 0 });
lenfix[1] = (code)({ 0, 8, 80 });
lenfix[2] = (code)({ 0, 8, 16 });
lenfix[3] = (code)({ 20, 8, 115 });
lenfix[4] = (code)({ 18, 7, 31 });
lenfix[5] = (code)({ 0, 8, 112 });
lenfix[6] = (code)({ 0, 8, 48 });
lenfix[7] = (code)({ 0, 9, 192 });
lenfix[8] = (code)({ 16, 7, 10 });
lenfix[9] = (code)({ 0, 8, 96 });
lenfix[10] = (code)({ 0, 8, 32 });
lenfix[11] = (code)({ 0, 9, 160 });
lenfix[12] = (code)({ 0, 8, 0 });
lenfix[13] = (code)({ 0, 8, 128 });
lenfix[14] = (code)({ 0, 8, 64 });
lenfix[15] = (code)({ 0, 9, 224 });
lenfix[16] = (code)({ 16, 7, 6 });
lenfix[17] = (code)({ 0, 8, 88 });
lenfix[18] = (code)({ 0, 8, 24 });
lenfix[19] = (code)({ 0, 9, 144 });
lenfix[20] = (code)({ 19, 7, 59 });
lenfix[21] = (code)({ 0, 8, 120 });
lenfix[22] = (code)({ 0, 8, 56 });
lenfix[23] = (code)({ 0, 9, 208 });
lenfix[24] = (code)({ 17, 7, 17 });
lenfix[25] = (code)({ 0, 8, 104 });
lenfix[26] = (code)({ 0, 8, 40 });
lenfix[27] = (code)({ 0, 9, 176 });
lenfix[28] = (code)({ 0, 8, 8 });
lenfix[29] = (code)({ 0, 8, 136 });
lenfix[30] = (code)({ 0, 8, 72 });
lenfix[31] = (code)({ 0, 9, 240 });
lenfix[32] = (code)({ 16, 7, 4 });
lenfix[33] = (code)({ 0, 8, 84 });
lenfix[34] = (code)({ 0, 8, 20 });
lenfix[35] = (code)({ 21, 8, 227 });
lenfix[36] = (code)({ 19, 7, 43 });
lenfix[37] = (code)({ 0, 8, 116 });
lenfix[38] = (code)({ 0, 8, 52 });
lenfix[39] = (code)({ 0, 9, 200 });
lenfix[40] = (code)({ 17, 7, 13 });
lenfix[41] = (code)({ 0, 8, 100 });
lenfix[42] = (code)({ 0, 8, 36 });
lenfix[43] = (code)({ 0, 9, 168 });
lenfix[44] = (code)({ 0, 8, 4 });
lenfix[45] = (code)({ 0, 8, 132 });
lenfix[46] = (code)({ 0, 8, 68 });
lenfix[47] = (code)({ 0, 9, 232 });
lenfix[48] = (code)({ 16, 7, 8 });
lenfix[49] = (code)({ 0, 8, 92 });
lenfix[50] = (code)({ 0, 8, 28 });
lenfix[51] = (code)({ 0, 9, 152 });
lenfix[52] = (code)({ 20, 7, 83 });
lenfix[53] = (code)({ 0, 8, 124 });
lenfix[54] = (code)({ 0, 8, 60 });
lenfix[55] = (code)({ 0, 9, 216 });
lenfix[56] = (code)({ 18, 7, 23 });
lenfix[57] = (code)({ 0, 8, 108 });
lenfix[58] = (code)({ 0, 8, 44 });
lenfix[59] = (code)({ 0, 9, 184 });
lenfix[60] = (code)({ 0, 8, 12 });
lenfix[61] = (code)({ 0, 8, 140 });
lenfix[62] = (code)({ 0, 8, 76 });
lenfix[63] = (code)({ 0, 9, 248 });
lenfix[64] = (code)({ 16, 7, 3 });
lenfix[65] = (code)({ 0, 8, 82 });
lenfix[66] = (code)({ 0, 8, 18 });
lenfix[67] = (code)({ 21, 8, 163 });
lenfix[68] = (code)({ 19, 7, 35 });
lenfix[69] = (code)({ 0, 8, 114 });
lenfix[70] = (code)({ 0, 8, 50 });
lenfix[71] = (code)({ 0, 9, 196 });
lenfix[72] = (code)({ 17, 7, 11 });
lenfix[73] = (code)({ 0, 8, 98 });
lenfix[74] = (code)({ 0, 8, 34 });
lenfix[75] = (code)({ 0, 9, 164 });
lenfix[76] = (code)({ 0, 8, 2 });
lenfix[77] = (code)({ 0, 8, 130 });
lenfix[78] = (code)({ 0, 8, 66 });
lenfix[79] = (code)({ 0, 9, 228 });
lenfix[80] = (code)({ 16, 7, 7 });
lenfix[81] = (code)({ 0, 8, 90 });
lenfix[82] = (code)({ 0, 8, 26 });
lenfix[83] = (code)({ 0, 9, 148 });
lenfix[84] = (code)({ 20, 7, 67 });
lenfix[85] = (code)({ 0, 8, 122 });
lenfix[86] = (code)({ 0, 8, 58 });
lenfix[87] = (code)({ 0, 9, 212 });
lenfix[88] = (code)({ 18, 7, 19 });
lenfix[89] = (code)({ 0, 8, 106 });
lenfix[90] = (code)({ 0, 8, 42 });
lenfix[91] = (code)({ 0, 9, 180 });
lenfix[92] = (code)({ 0, 8, 10 });
lenfix[93] = (code)({ 0, 8, 138 });
lenfix[94] = (code)({ 0, 8, 74 });
lenfix[95] = (code)({ 0, 9, 244 });
lenfix[96] = (code)({ 16, 7, 5 });
lenfix[97] = (code)({ 0, 8, 86 });
lenfix[98] = (code)({ 0, 8, 22 });
lenfix[99] = (code)({ 64, 8, 0 });
lenfix[100] = (code)({ 19, 7, 51 });
lenfix[101] = (code)({ 0, 8, 118 });
lenfix[102] = (code)({ 0, 8, 54 });
lenfix[103] = (code)({ 0, 9, 204 });
lenfix[104] = (code)({ 17, 7, 15 });
lenfix[105] = (code)({ 0, 8, 102 });
lenfix[106] = (code)({ 0, 8, 38 });
lenfix[107] = (code)({ 0, 9, 172 });
lenfix[108] = (code)({ 0, 8, 6 });
lenfix[109] = (code)({ 0, 8, 134 });
lenfix[110] = (code)({ 0, 8, 70 });
lenfix[111] = (code)({ 0, 9, 236 });
lenfix[112] = (code)({ 16, 7, 9 });
lenfix[113] = (code)({ 0, 8, 94 });
lenfix[114] = (code)({ 0, 8, 30 });
lenfix[115] = (code)({ 0, 9, 156 });
lenfix[116] = (code)({ 20, 7, 99 });
lenfix[117] = (code)({ 0, 8, 126 });
lenfix[118] = (code)({ 0, 8, 62 });
lenfix[119] = (code)({ 0, 9, 220 });
lenfix[120] = (code)({ 18, 7, 27 });
lenfix[121] = (code)({ 0, 8, 110 });
lenfix[122] = (code)({ 0, 8, 46 });
lenfix[123] = (code)({ 0, 9, 188 });
lenfix[124] = (code)({ 0, 8, 14 });
lenfix[125] = (code)({ 0, 8, 142 });
lenfix[126] = (code)({ 0, 8, 78 });
lenfix[127] = (code)({ 0, 9, 252 });
lenfix[128] = (code)({ 96, 7, 0 });
lenfix[129] = (code)({ 0, 8, 81 });
lenfix[130] = (code)({ 0, 8, 17 });
lenfix[131] = (code)({ 21, 8, 131 });
lenfix[132] = (code)({ 18, 7, 31 });
lenfix[133] = (code)({ 0, 8, 113 });
lenfix[134] = (code)({ 0, 8, 49 });
lenfix[135] = (code)({ 0, 9, 194 });
lenfix[136] = (code)({ 16, 7, 10 });
lenfix[137] = (code)({ 0, 8, 97 });
lenfix[138] = (code)({ 0, 8, 33 });
lenfix[139] = (code)({ 0, 9, 162 });
lenfix[140] = (code)({ 0, 8, 1 });
lenfix[141] = (code)({ 0, 8, 129 });
lenfix[142] = (code)({ 0, 8, 65 });
lenfix[143] = (code)({ 0, 9, 226 });
lenfix[144] = (code)({ 16, 7, 6 });
lenfix[145] = (code)({ 0, 8, 89 });
lenfix[146] = (code)({ 0, 8, 25 });
lenfix[147] = (code)({ 0, 9, 146 });
lenfix[148] = (code)({ 19, 7, 59 });
lenfix[149] = (code)({ 0, 8, 121 });
lenfix[150] = (code)({ 0, 8, 57 });
lenfix[151] = (code)({ 0, 9, 210 });
lenfix[152] = (code)({ 17, 7, 17 });
lenfix[153] = (code)({ 0, 8, 105 });
lenfix[154] = (code)({ 0, 8, 41 });
lenfix[155] = (code)({ 0, 9, 178 });
lenfix[156] = (code)({ 0, 8, 9 });
lenfix[157] = (code)({ 0, 8, 137 });
lenfix[158] = (code)({ 0, 8, 73 });
lenfix[159] = (code)({ 0, 9, 242 });
lenfix[160] = (code)({ 16, 7, 4 });
lenfix[161] = (code)({ 0, 8, 85 });
lenfix[162] = (code)({ 0, 8, 21 });
lenfix[163] = (code)({ 16, 8, 258 });
lenfix[164] = (code)({ 19, 7, 43 });
lenfix[165] = (code)({ 0, 8, 117 });
lenfix[166] = (code)({ 0, 8, 53 });
lenfix[167] = (code)({ 0, 9, 202 });
lenfix[168] = (code)({ 17, 7, 13 });
lenfix[169] = (code)({ 0, 8, 101 });
lenfix[170] = (code)({ 0, 8, 37 });
lenfix[171] = (code)({ 0, 9, 170 });
lenfix[172] = (code)({ 0, 8, 5 });
lenfix[173] = (code)({ 0, 8, 133 });
lenfix[174] = (code)({ 0, 8, 69 });
lenfix[175] = (code)({ 0, 9, 234 });
lenfix[176] = (code)({ 16, 7, 8 });
lenfix[177] = (code)({ 0, 8, 93 });
lenfix[178] = (code)({ 0, 8, 29 });
lenfix[179] = (code)({ 0, 9, 154 });
lenfix[180] = (code)({ 20, 7, 83 });
lenfix[181] = (code)({ 0, 8, 125 });
lenfix[182] = (code)({ 0, 8, 61 });
lenfix[183] = (code)({ 0, 9, 218 });
lenfix[184] = (code)({ 18, 7, 23 });
lenfix[185] = (code)({ 0, 8, 109 });
lenfix[186] = (code)({ 0, 8, 45 });
lenfix[187] = (code)({ 0, 9, 186 });
lenfix[188] = (code)({ 0, 8, 13 });
lenfix[189] = (code)({ 0, 8, 141 });
lenfix[190] = (code)({ 0, 8, 77 });
lenfix[191] = (code)({ 0, 9, 250 });
lenfix[192] = (code)({ 16, 7, 3 });
lenfix[193] = (code)({ 0, 8, 83 });
lenfix[194] = (code)({ 0, 8, 19 });
lenfix[195] = (code)({ 21, 8, 195 });
lenfix[196] = (code)({ 19, 7, 35 });
lenfix[197] = (code)({ 0, 8, 115 });
lenfix[198] = (code)({ 0, 8, 51 });
lenfix[199] = (code)({ 0, 9, 198 });
lenfix[200] = (code)({ 17, 7, 11 });
lenfix[201] = (code)({ 0, 8, 99 });
lenfix[202] = (code)({ 0, 8, 35 });
lenfix[203] = (code)({ 0, 9, 166 });
lenfix[204] = (code)({ 0, 8, 3 });
lenfix[205] = (code)({ 0, 8, 131 });
lenfix[206] = (code)({ 0, 8, 67 });
lenfix[207] = (code)({ 0, 9, 230 });
lenfix[208] = (code)({ 16, 7, 7 });
lenfix[209] = (code)({ 0, 8, 91 });
lenfix[210] = (code)({ 0, 8, 27 });
lenfix[211] = (code)({ 0, 9, 150 });
lenfix[212] = (code)({ 20, 7, 67 });
lenfix[213] = (code)({ 0, 8, 123 });
lenfix[214] = (code)({ 0, 8, 59 });
lenfix[215] = (code)({ 0, 9, 214 });
lenfix[216] = (code)({ 18, 7, 19 });
lenfix[217] = (code)({ 0, 8, 107 });
lenfix[218] = (code)({ 0, 8, 43 });
lenfix[219] = (code)({ 0, 9, 182 });
lenfix[220] = (code)({ 0, 8, 11 });
lenfix[221] = (code)({ 0, 8, 139 });
lenfix[222] = (code)({ 0, 8, 75 });
lenfix[223] = (code)({ 0, 9, 246 });
lenfix[224] = (code)({ 16, 7, 5 });
lenfix[225] = (code)({ 0, 8, 87 });
lenfix[226] = (code)({ 0, 8, 23 });
lenfix[227] = (code)({ 64, 8, 0 });
lenfix[228] = (code)({ 19, 7, 51 });
lenfix[229] = (code)({ 0, 8, 119 });
lenfix[230] = (code)({ 0, 8, 55 });
lenfix[231] = (code)({ 0, 9, 206 });
lenfix[232] = (code)({ 17, 7, 15 });
lenfix[233] = (code)({ 0, 8, 103 });
lenfix[234] = (code)({ 0, 8, 39 });
lenfix[235] = (code)({ 0, 9, 174 });
lenfix[236] = (code)({ 0, 8, 7 });
lenfix[237] = (code)({ 0, 8, 135 });
lenfix[238] = (code)({ 0, 8, 71 });
lenfix[239] = (code)({ 0, 9, 238 });
lenfix[240] = (code)({ 16, 7, 9 });
lenfix[241] = (code)({ 0, 8, 95 });
lenfix[242] = (code)({ 0, 8, 31 });
lenfix[243] = (code)({ 0, 9, 158 });
lenfix[244] = (code)({ 20, 7, 99 });
lenfix[245] = (code)({ 0, 8, 127 });
lenfix[246] = (code)({ 0, 8, 63 });
lenfix[247] = (code)({ 0, 9, 222 });
lenfix[248] = (code)({ 18, 7, 27 });
lenfix[249] = (code)({ 0, 8, 111 });
lenfix[250] = (code)({ 0, 8, 47 });
lenfix[251] = (code)({ 0, 9, 190 });
lenfix[252] = (code)({ 0, 8, 15 });
lenfix[253] = (code)({ 0, 8, 143 });
lenfix[254] = (code)({ 0, 8, 79 });
lenfix[255] = (code)({ 0, 9, 254 });
lenfix[256] = (code)({ 96, 7, 0 });
lenfix[257] = (code)({ 0, 8, 80 });
lenfix[258] = (code)({ 0, 8, 16 });
lenfix[259] = (code)({ 20, 8, 115 });
lenfix[260] = (code)({ 18, 7, 31 });
lenfix[261] = (code)({ 0, 8, 112 });
lenfix[262] = (code)({ 0, 8, 48 });
lenfix[263] = (code)({ 0, 9, 193 });
lenfix[264] = (code)({ 16, 7, 10 });
lenfix[265] = (code)({ 0, 8, 96 });
lenfix[266] = (code)({ 0, 8, 32 });
lenfix[267] = (code)({ 0, 9, 161 });
lenfix[268] = (code)({ 0, 8, 0 });
lenfix[269] = (code)({ 0, 8, 128 });
lenfix[270] = (code)({ 0, 8, 64 });
lenfix[271] = (code)({ 0, 9, 225 });
lenfix[272] = (code)({ 16, 7, 6 });
lenfix[273] = (code)({ 0, 8, 88 });
lenfix[274] = (code)({ 0, 8, 24 });
lenfix[275] = (code)({ 0, 9, 145 });
lenfix[276] = (code)({ 19, 7, 59 });
lenfix[277] = (code)({ 0, 8, 120 });
lenfix[278] = (code)({ 0, 8, 56 });
lenfix[279] = (code)({ 0, 9, 209 });
lenfix[280] = (code)({ 17, 7, 17 });
lenfix[281] = (code)({ 0, 8, 104 });
lenfix[282] = (code)({ 0, 8, 40 });
lenfix[283] = (code)({ 0, 9, 177 });
lenfix[284] = (code)({ 0, 8, 8 });
lenfix[285] = (code)({ 0, 8, 136 });
lenfix[286] = (code)({ 0, 8, 72 });
lenfix[287] = (code)({ 0, 9, 241 });
lenfix[288] = (code)({ 16, 7, 4 });
lenfix[289] = (code)({ 0, 8, 84 });
lenfix[290] = (code)({ 0, 8, 20 });
lenfix[291] = (code)({ 21, 8, 227 });
lenfix[292] = (code)({ 19, 7, 43 });
lenfix[293] = (code)({ 0, 8, 116 });
lenfix[294] = (code)({ 0, 8, 52 });
lenfix[295] = (code)({ 0, 9, 201 });
lenfix[296] = (code)({ 17, 7, 13 });
lenfix[297] = (code)({ 0, 8, 100 });
lenfix[298] = (code)({ 0, 8, 36 });
lenfix[299] = (code)({ 0, 9, 169 });
lenfix[300] = (code)({ 0, 8, 4 });
lenfix[301] = (code)({ 0, 8, 132 });
lenfix[302] = (code)({ 0, 8, 68 });
lenfix[303] = (code)({ 0, 9, 233 });
lenfix[304] = (code)({ 16, 7, 8 });
lenfix[305] = (code)({ 0, 8, 92 });
lenfix[306] = (code)({ 0, 8, 28 });
lenfix[307] = (code)({ 0, 9, 153 });
lenfix[308] = (code)({ 20, 7, 83 });
lenfix[309] = (code)({ 0, 8, 124 });
lenfix[310] = (code)({ 0, 8, 60 });
lenfix[311] = (code)({ 0, 9, 217 });
lenfix[312] = (code)({ 18, 7, 23 });
lenfix[313] = (code)({ 0, 8, 108 });
lenfix[314] = (code)({ 0, 8, 44 });
lenfix[315] = (code)({ 0, 9, 185 });
lenfix[316] = (code)({ 0, 8, 12 });
lenfix[317] = (code)({ 0, 8, 140 });
lenfix[318] = (code)({ 0, 8, 76 });
lenfix[319] = (code)({ 0, 9, 249 });
lenfix[320] = (code)({ 16, 7, 3 });
lenfix[321] = (code)({ 0, 8, 82 });
lenfix[322] = (code)({ 0, 8, 18 });
lenfix[323] = (code)({ 21, 8, 163 });
lenfix[324] = (code)({ 19, 7, 35 });
lenfix[325] = (code)({ 0, 8, 114 });
lenfix[326] = (code)({ 0, 8, 50 });
lenfix[327] = (code)({ 0, 9, 197 });
lenfix[328] = (code)({ 17, 7, 11 });
lenfix[329] = (code)({ 0, 8, 98 });
lenfix[330] = (code)({ 0, 8, 34 });
lenfix[331] = (code)({ 0, 9, 165 });
lenfix[332] = (code)({ 0, 8, 2 });
lenfix[333] = (code)({ 0, 8, 130 });
lenfix[334] = (code)({ 0, 8, 66 });
lenfix[335] = (code)({ 0, 9, 229 });
lenfix[336] = (code)({ 16, 7, 7 });
lenfix[337] = (code)({ 0, 8, 90 });
lenfix[338] = (code)({ 0, 8, 26 });
lenfix[339] = (code)({ 0, 9, 149 });
lenfix[340] = (code)({ 20, 7, 67 });
lenfix[341] = (code)({ 0, 8, 122 });
lenfix[342] = (code)({ 0, 8, 58 });
lenfix[343] = (code)({ 0, 9, 213 });
lenfix[344] = (code)({ 18, 7, 19 });
lenfix[345] = (code)({ 0, 8, 106 });
lenfix[346] = (code)({ 0, 8, 42 });
lenfix[347] = (code)({ 0, 9, 181 });
lenfix[348] = (code)({ 0, 8, 10 });
lenfix[349] = (code)({ 0, 8, 138 });
lenfix[350] = (code)({ 0, 8, 74 });
lenfix[351] = (code)({ 0, 9, 245 });
lenfix[352] = (code)({ 16, 7, 5 });
lenfix[353] = (code)({ 0, 8, 86 });
lenfix[354] = (code)({ 0, 8, 22 });
lenfix[355] = (code)({ 64, 8, 0 });
lenfix[356] = (code)({ 19, 7, 51 });
lenfix[357] = (code)({ 0, 8, 118 });
lenfix[358] = (code)({ 0, 8, 54 });
lenfix[359] = (code)({ 0, 9, 205 });
lenfix[360] = (code)({ 17, 7, 15 });
lenfix[361] = (code)({ 0, 8, 102 });
lenfix[362] = (code)({ 0, 8, 38 });
lenfix[363] = (code)({ 0, 9, 173 });
lenfix[364] = (code)({ 0, 8, 6 });
lenfix[365] = (code)({ 0, 8, 134 });
lenfix[366] = (code)({ 0, 8, 70 });
lenfix[367] = (code)({ 0, 9, 237 });
lenfix[368] = (code)({ 16, 7, 9 });
lenfix[369] = (code)({ 0, 8, 94 });
lenfix[370] = (code)({ 0, 8, 30 });
lenfix[371] = (code)({ 0, 9, 157 });
lenfix[372] = (code)({ 20, 7, 99 });
lenfix[373] = (code)({ 0, 8, 126 });
lenfix[374] = (code)({ 0, 8, 62 });
lenfix[375] = (code)({ 0, 9, 221 });
lenfix[376] = (code)({ 18, 7, 27 });
lenfix[377] = (code)({ 0, 8, 110 });
lenfix[378] = (code)({ 0, 8, 46 });
lenfix[379] = (code)({ 0, 9, 189 });
lenfix[380] = (code)({ 0, 8, 14 });
lenfix[381] = (code)({ 0, 8, 142 });
lenfix[382] = (code)({ 0, 8, 78 });
lenfix[383] = (code)({ 0, 9, 253 });
lenfix[384] = (code)({ 96, 7, 0 });
lenfix[385] = (code)({ 0, 8, 81 });
lenfix[386] = (code)({ 0, 8, 17 });
lenfix[387] = (code)({ 21, 8, 131 });
lenfix[388] = (code)({ 18, 7, 31 });
lenfix[389] = (code)({ 0, 8, 113 });
lenfix[390] = (code)({ 0, 8, 49 });
lenfix[391] = (code)({ 0, 9, 195 });
lenfix[392] = (code)({ 16, 7, 10 });
lenfix[393] = (code)({ 0, 8, 97 });
lenfix[394] = (code)({ 0, 8, 33 });
lenfix[395] = (code)({ 0, 9, 163 });
lenfix[396] = (code)({ 0, 8, 1 });
lenfix[397] = (code)({ 0, 8, 129 });
lenfix[398] = (code)({ 0, 8, 65 });
lenfix[399] = (code)({ 0, 9, 227 });
lenfix[400] = (code)({ 16, 7, 6 });
lenfix[401] = (code)({ 0, 8, 89 });
lenfix[402] = (code)({ 0, 8, 25 });
lenfix[403] = (code)({ 0, 9, 147 });
lenfix[404] = (code)({ 19, 7, 59 });
lenfix[405] = (code)({ 0, 8, 121 });
lenfix[406] = (code)({ 0, 8, 57 });
lenfix[407] = (code)({ 0, 9, 211 });
lenfix[408] = (code)({ 17, 7, 17 });
lenfix[409] = (code)({ 0, 8, 105 });
lenfix[410] = (code)({ 0, 8, 41 });
lenfix[411] = (code)({ 0, 9, 179 });
lenfix[412] = (code)({ 0, 8, 9 });
lenfix[413] = (code)({ 0, 8, 137 });
lenfix[414] = (code)({ 0, 8, 73 });
lenfix[415] = (code)({ 0, 9, 243 });
lenfix[416] = (code)({ 16, 7, 4 });
lenfix[417] = (code)({ 0, 8, 85 });
lenfix[418] = (code)({ 0, 8, 21 });
lenfix[419] = (code)({ 16, 8, 258 });
lenfix[420] = (code)({ 19, 7, 43 });
lenfix[421] = (code)({ 0, 8, 117 });
lenfix[422] = (code)({ 0, 8, 53 });
lenfix[423] = (code)({ 0, 9, 203 });
lenfix[424] = (code)({ 17, 7, 13 });
lenfix[425] = (code)({ 0, 8, 101 });
lenfix[426] = (code)({ 0, 8, 37 });
lenfix[427] = (code)({ 0, 9, 171 });
lenfix[428] = (code)({ 0, 8, 5 });
lenfix[429] = (code)({ 0, 8, 133 });
lenfix[430] = (code)({ 0, 8, 69 });
lenfix[431] = (code)({ 0, 9, 235 });
lenfix[432] = (code)({ 16, 7, 8 });
lenfix[433] = (code)({ 0, 8, 93 });
lenfix[434] = (code)({ 0, 8, 29 });
lenfix[435] = (code)({ 0, 9, 155 });
lenfix[436] = (code)({ 20, 7, 83 });
lenfix[437] = (code)({ 0, 8, 125 });
lenfix[438] = (code)({ 0, 8, 61 });
lenfix[439] = (code)({ 0, 9, 219 });
lenfix[440] = (code)({ 18, 7, 23 });
lenfix[441] = (code)({ 0, 8, 109 });
lenfix[442] = (code)({ 0, 8, 45 });
lenfix[443] = (code)({ 0, 9, 187 });
lenfix[444] = (code)({ 0, 8, 13 });
lenfix[445] = (code)({ 0, 8, 141 });
lenfix[446] = (code)({ 0, 8, 77 });
lenfix[447] = (code)({ 0, 9, 251 });
lenfix[448] = (code)({ 16, 7, 3 });
lenfix[449] = (code)({ 0, 8, 83 });
lenfix[450] = (code)({ 0, 8, 19 });
lenfix[451] = (code)({ 21, 8, 195 });
lenfix[452] = (code)({ 19, 7, 35 });
lenfix[453] = (code)({ 0, 8, 115 });
lenfix[454] = (code)({ 0, 8, 51 });
lenfix[455] = (code)({ 0, 9, 199 });
lenfix[456] = (code)({ 17, 7, 11 });
lenfix[457] = (code)({ 0, 8, 99 });
lenfix[458] = (code)({ 0, 8, 35 });
lenfix[459] = (code)({ 0, 9, 167 });
lenfix[460] = (code)({ 0, 8, 3 });
lenfix[461] = (code)({ 0, 8, 131 });
lenfix[462] = (code)({ 0, 8, 67 });
lenfix[463] = (code)({ 0, 9, 231 });
lenfix[464] = (code)({ 16, 7, 7 });
lenfix[465] = (code)({ 0, 8, 91 });
lenfix[466] = (code)({ 0, 8, 27 });
lenfix[467] = (code)({ 0, 9, 151 });
lenfix[468] = (code)({ 20, 7, 67 });
lenfix[469] = (code)({ 0, 8, 123 });
lenfix[470] = (code)({ 0, 8, 59 });
lenfix[471] = (code)({ 0, 9, 215 });
lenfix[472] = (code)({ 18, 7, 19 });
lenfix[473] = (code)({ 0, 8, 107 });
lenfix[474] = (code)({ 0, 8, 43 });
lenfix[475] = (code)({ 0, 9, 183 });
lenfix[476] = (code)({ 0, 8, 11 });
lenfix[477] = (code)({ 0, 8, 139 });
lenfix[478] = (code)({ 0, 8, 75 });
lenfix[479] = (code)({ 0, 9, 247 });
lenfix[480] = (code)({ 16, 7, 5 });
lenfix[481] = (code)({ 0, 8, 87 });
lenfix[482] = (code)({ 0, 8, 23 });
lenfix[483] = (code)({ 64, 8, 0 });
lenfix[484] = (code)({ 19, 7, 51 });
lenfix[485] = (code)({ 0, 8, 119 });
lenfix[486] = (code)({ 0, 8, 55 });
lenfix[487] = (code)({ 0, 9, 207 });
lenfix[488] = (code)({ 17, 7, 15 });
lenfix[489] = (code)({ 0, 8, 103 });
lenfix[490] = (code)({ 0, 8, 39 });
lenfix[491] = (code)({ 0, 9, 175 });
lenfix[492] = (code)({ 0, 8, 7 });
lenfix[493] = (code)({ 0, 8, 135 });
lenfix[494] = (code)({ 0, 8, 71 });
lenfix[495] = (code)({ 0, 9, 239 });
lenfix[496] = (code)({ 16, 7, 9 });
lenfix[497] = (code)({ 0, 8, 95 });
lenfix[498] = (code)({ 0, 8, 31 });
lenfix[499] = (code)({ 0, 9, 159 });
lenfix[500] = (code)({ 20, 7, 99 });
lenfix[501] = (code)({ 0, 8, 127 });
lenfix[502] = (code)({ 0, 8, 63 });
lenfix[503] = (code)({ 0, 9, 223 });
lenfix[504] = (code)({ 18, 7, 27 });
lenfix[505] = (code)({ 0, 8, 111 });
lenfix[506] = (code)({ 0, 8, 47 });
lenfix[507] = (code)({ 0, 9, 191 });
lenfix[508] = (code)({ 0, 8, 15 });
lenfix[509] = (code)({ 0, 8, 143 });
lenfix[510] = (code)({ 0, 8, 79 });
lenfix[511] = (code)({ 0, 9, 255 });

			code* distfix = stackalloc code[32];
distfix[0] = (code)({ 16, 5, 1 });
distfix[1] = (code)({ 23, 5, 257 });
distfix[2] = (code)({ 19, 5, 17 });
distfix[3] = (code)({ 27, 5, 4097 });
distfix[4] = (code)({ 17, 5, 5 });
distfix[5] = (code)({ 25, 5, 1025 });
distfix[6] = (code)({ 21, 5, 65 });
distfix[7] = (code)({ 29, 5, 16385 });
distfix[8] = (code)({ 16, 5, 3 });
distfix[9] = (code)({ 24, 5, 513 });
distfix[10] = (code)({ 20, 5, 33 });
distfix[11] = (code)({ 28, 5, 8193 });
distfix[12] = (code)({ 18, 5, 9 });
distfix[13] = (code)({ 26, 5, 2049 });
distfix[14] = (code)({ 22, 5, 129 });
distfix[15] = (code)({ 64, 5, 0 });
distfix[16] = (code)({ 16, 5, 2 });
distfix[17] = (code)({ 23, 5, 385 });
distfix[18] = (code)({ 19, 5, 25 });
distfix[19] = (code)({ 27, 5, 6145 });
distfix[20] = (code)({ 17, 5, 7 });
distfix[21] = (code)({ 25, 5, 1537 });
distfix[22] = (code)({ 21, 5, 97 });
distfix[23] = (code)({ 29, 5, 24577 });
distfix[24] = (code)({ 16, 5, 4 });
distfix[25] = (code)({ 24, 5, 769 });
distfix[26] = (code)({ 20, 5, 49 });
distfix[27] = (code)({ 28, 5, 12289 });
distfix[28] = (code)({ 18, 5, 13 });
distfix[29] = (code)({ 26, 5, 3073 });
distfix[30] = (code)({ 22, 5, 193 });
distfix[31] = (code)({ 64, 5, 0 });

			state->lencode = lenfix;
			state->lenbits = (uint)(9);
			state->distcode = distfix;
			state->distbits = (uint)(5);
		}

		public static int updatewindow(z_stream_s strm, byte* end, uint copy)
		{
			inflate_state state;
			uint dist = 0;
			state = (inflate_state)(strm.state);
			if ((state->window) == (null)) {
state->window = (byte*)(strm.zalloc(strm.opaque, (uint)(1U << state->wbits), (uint)(sizeof(unsignedchar))));if ((state->window) == (null)) return (int)(1);}

			if ((state->wsize) == (0)) {
state->wsize = (uint)(1U << state->wbits);state->wnext = (uint)(0);state->whave = (uint)(0);}

			if ((copy) >= (state->wsize)) {
memcpy(state->window, end - state->wsize, (ulong)(state->wsize));state->wnext = (uint)(0);state->whave = (uint)(state->wsize);}
 else {
dist = (uint)(state->wsize - state->wnext);if ((dist) > (copy)) dist = (uint)(copy);memcpy(state->window + state->wnext, end - copy, (ulong)(dist));copy -= (uint)(dist);if ((copy) != 0) {
memcpy(state->window, end - copy, (ulong)(copy));state->wnext = (uint)(copy);state->whave = (uint)(state->wsize);}
 else {
state->wnext += (uint)(dist);if ((state->wnext) == (state->wsize)) state->wnext = (uint)(0);if ((state->whave) < (state->wsize)) state->whave += (uint)(dist);}
}

			return (int)(0);
		}

		public static int inflate(z_stream_s strm, int flush)
		{
			inflate_state state;
			byte* next;
			byte* put;
			uint have = 0;uint left = 0;
			int hold = 0;
			uint bits = 0;
			uint _in_ = 0;uint _out_ = 0;
			uint copy = 0;
			byte* from;
			code here = new code();
			code last = new code();
			uint len = 0;
			int ret = 0;
			byte* hbuf = stackalloc byte[4];
			ushort* order = stackalloc ushort[19];
order[0] = (ushort)(16);
order[1] = (ushort)(17);
order[2] = (ushort)(18);
order[3] = (ushort)(0);
order[4] = (ushort)(8);
order[5] = (ushort)(7);
order[6] = (ushort)(9);
order[7] = (ushort)(6);
order[8] = (ushort)(10);
order[9] = (ushort)(5);
order[10] = (ushort)(11);
order[11] = (ushort)(4);
order[12] = (ushort)(12);
order[13] = (ushort)(3);
order[14] = (ushort)(13);
order[15] = (ushort)(2);
order[16] = (ushort)(14);
order[17] = (ushort)(1);
order[18] = (ushort)(15);

			if ((((inflateStateCheck(strm)) != 0) || ((strm.next_out) == (null))) || (((strm.next_in) == (null)) && (strm.avail_in != 0))) return (int)(-2);
			state = (inflate_state)(strm.state);
			if ((state->mode) == (TYPE)) state->mode = (inflate_mode)(TYPEDO);
			do {
put = strm.next_out;left = (uint)(strm.avail_out);next = strm.next_in;have = (uint)(strm.avail_in);hold = (int)(state->hold);bits = (uint)(state->bits);}
 while ((0) != 0);
			_in_ = (uint)(have);
			_out_ = (uint)(left);
			ret = (int)(0);
			for (; ; ) {switch (state->mode){
case HEAD:if ((state->wrap) == (0)) {
state->mode = (inflate_mode)(TYPEDO);break;}
do {
while ((bits) < ((uint)(16))) {do {
if ((have) == (0)) goto inf_leave;have--;hold += (int)((int)(*next++) << bits);bits += (uint)(8);}
 while ((0) != 0);}}
 while ((0) != 0);if (((state->wrap & 2)!= 0) && ((hold) == (0x8b1f))) {
if ((state->wbits) == (0)) state->wbits = (uint)(15);state->check = (int)(crc32((int)(0L), null, (uint)(0)));do {
hbuf[0] = ((byte)(hold));hbuf[1] = ((byte)((hold) >> 8));state->check = (int)(crc32((int)(state->check), hbuf, (uint)(2)));}
 while ((0) != 0);do {
hold = (int)(0);bits = (uint)(0);}
 while ((0) != 0);state->mode = (inflate_mode)(FLAGS);break;}
state->flags = (int)(0);if (state->head != null) state->head->done = (int)(-1);if (((state->wrap & 1)== 0) || (((((uint)(hold) & ((1U << (8)) - 1)) << 8) + (hold >> 8)) % 31)) {
strm.msg = "incorrect header check";state->mode = (inflate_mode)(BAD);break;}
if (((uint)(hold) & ((1U << (4)) - 1)) != 8) {
strm.msg = "unknown compression method";state->mode = (inflate_mode)(BAD);break;}
do {
hold >>= (4);bits -= ((uint)(4));}
 while ((0) != 0);len = (uint)(((uint)(hold) & ((1U << (4)) - 1)) + 8);if ((state->wbits) == (0)) state->wbits = (uint)(len);if (((len) > (15)) || ((len) > (state->wbits))) {
strm.msg = "invalid window size";state->mode = (inflate_mode)(BAD);break;}
state->dmax = (uint)(1U << len);strm.adler = (int)(state->check = (int)(adler32((int)(0L), null, (uint)(0))));state->mode = (inflate_mode)((hold & 0x200) != 0?DICTID:TYPE);do {
hold = (int)(0);bits = (uint)(0);}
 while ((0) != 0);break;case FLAGS:do {
while ((bits) < ((uint)(16))) {do {
if ((have) == (0)) goto inf_leave;have--;hold += (int)((int)(*next++) << bits);bits += (uint)(8);}
 while ((0) != 0);}}
 while ((0) != 0);state->flags = (int)(hold);if ((state->flags & 0xff) != 8) {
strm.msg = "unknown compression method";state->mode = (inflate_mode)(BAD);break;}
if ((state->flags & 0xe000) != 0) {
strm.msg = "unknown header flags set";state->mode = (inflate_mode)(BAD);break;}
if (state->head != null) state->head->text = (int)((hold >> 8) & 1);if (((state->flags & 0x0200)!= 0) && ((state->wrap & 4)!= 0)) do {
hbuf[0] = ((byte)(hold));hbuf[1] = ((byte)((hold) >> 8));state->check = (int)(crc32((int)(state->check), hbuf, (uint)(2)));}
 while ((0) != 0);do {
hold = (int)(0);bits = (uint)(0);}
 while ((0) != 0);state->mode = (inflate_mode)(TIME);case TIME:do {
while ((bits) < ((uint)(32))) {do {
if ((have) == (0)) goto inf_leave;have--;hold += (int)((int)(*next++) << bits);bits += (uint)(8);}
 while ((0) != 0);}}
 while ((0) != 0);if (state->head != null) state->head->time = (int)(hold);if (((state->flags & 0x0200)!= 0) && ((state->wrap & 4)!= 0)) do {
hbuf[0] = ((byte)(hold));hbuf[1] = ((byte)((hold) >> 8));hbuf[2] = ((byte)((hold) >> 16));hbuf[3] = ((byte)((hold) >> 24));state->check = (int)(crc32((int)(state->check), hbuf, (uint)(4)));}
 while ((0) != 0);do {
hold = (int)(0);bits = (uint)(0);}
 while ((0) != 0);state->mode = (inflate_mode)(OS);case OS:do {
while ((bits) < ((uint)(16))) {do {
if ((have) == (0)) goto inf_leave;have--;hold += (int)((int)(*next++) << bits);bits += (uint)(8);}
 while ((0) != 0);}}
 while ((0) != 0);if (state->head != null) {
state->head->xflags = (int)(hold & 0xff);state->head->os = (int)(hold >> 8);}
if (((state->flags & 0x0200)!= 0) && ((state->wrap & 4)!= 0)) do {
hbuf[0] = ((byte)(hold));hbuf[1] = ((byte)((hold) >> 8));state->check = (int)(crc32((int)(state->check), hbuf, (uint)(2)));}
 while ((0) != 0);do {
hold = (int)(0);bits = (uint)(0);}
 while ((0) != 0);state->mode = (inflate_mode)(EXLEN);case EXLEN:if ((state->flags & 0x0400) != 0) {
do {
while ((bits) < ((uint)(16))) {do {
if ((have) == (0)) goto inf_leave;have--;hold += (int)((int)(*next++) << bits);bits += (uint)(8);}
 while ((0) != 0);}}
 while ((0) != 0);state->length = ((uint)(hold));if (state->head != null) state->head->extra_len = ((uint)(hold));if (((state->flags & 0x0200)!= 0) && ((state->wrap & 4)!= 0)) do {
hbuf[0] = ((byte)(hold));hbuf[1] = ((byte)((hold) >> 8));state->check = (int)(crc32((int)(state->check), hbuf, (uint)(2)));}
 while ((0) != 0);do {
hold = (int)(0);bits = (uint)(0);}
 while ((0) != 0);}
 else if (state->head != null) state->head->extra = null;state->mode = (inflate_mode)(EXTRA);case EXTRA:if ((state->flags & 0x0400) != 0) {
copy = (uint)(state->length);if ((copy) > (have)) copy = (uint)(have);if ((copy) != 0) {
if ((state->head != null) && (state->head->extra != null)) {
len = (uint)(state->head->extra_len - state->length);memcpy(state->head->extra + len, next, (ulong)((len + copy) > (state->head->extra_max)?state->head->extra_max - len:copy));}
if (((state->flags & 0x0200)!= 0) && ((state->wrap & 4)!= 0)) state->check = (int)(crc32((int)(state->check), next, (uint)(copy)));have -= (uint)(copy);next += copy;state->length -= (uint)(copy);}
if ((state->length) != 0) goto inf_leave;}
state->length = (uint)(0);state->mode = (inflate_mode)(NAME);case NAME:if ((state->flags & 0x0800) != 0) {
if ((have) == (0)) goto inf_leave;copy = (uint)(0);do {
len = ((uint)(next[copy++]));if (((state->head != null) && (state->head->name != null)) && ((state->length) < (state->head->name_max))) state->head->name[state->length++] = ((byte)(len));}
 while (((len) != 0) && ((copy) < (have)));if (((state->flags & 0x0200)!= 0) && ((state->wrap & 4)!= 0)) state->check = (int)(crc32((int)(state->check), next, (uint)(copy)));have -= (uint)(copy);next += copy;if ((len) != 0) goto inf_leave;}
 else if (state->head != null) state->head->name = null;state->length = (uint)(0);state->mode = (inflate_mode)(COMMENT);case COMMENT:if ((state->flags & 0x1000) != 0) {
if ((have) == (0)) goto inf_leave;copy = (uint)(0);do {
len = ((uint)(next[copy++]));if (((state->head != null) && (state->head->comment != null)) && ((state->length) < (state->head->comm_max))) state->head->comment[state->length++] = ((byte)(len));}
 while (((len) != 0) && ((copy) < (have)));if (((state->flags & 0x0200)!= 0) && ((state->wrap & 4)!= 0)) state->check = (int)(crc32((int)(state->check), next, (uint)(copy)));have -= (uint)(copy);next += copy;if ((len) != 0) goto inf_leave;}
 else if (state->head != null) state->head->comment = null;state->mode = (inflate_mode)(HCRC);case HCRC:if ((state->flags & 0x0200) != 0) {
do {
while ((bits) < ((uint)(16))) {do {
if ((have) == (0)) goto inf_leave;have--;hold += (int)((int)(*next++) << bits);bits += (uint)(8);}
 while ((0) != 0);}}
 while ((0) != 0);if (((state->wrap & 4)!= 0) && (hold != (state->check & 0xffff))) {
strm.msg = "header crc mismatch";state->mode = (inflate_mode)(BAD);break;}
do {
hold = (int)(0);bits = (uint)(0);}
 while ((0) != 0);}
if (state->head != null) {
state->head->hcrc = (int)((state->flags >> 9) & 1);state->head->done = (int)(1);}
strm.adler = (int)(state->check = (int)(crc32((int)(0L), null, (uint)(0))));state->mode = (inflate_mode)(TYPE);break;case DICTID:do {
while ((bits) < ((uint)(32))) {do {
if ((have) == (0)) goto inf_leave;have--;hold += (int)((int)(*next++) << bits);bits += (uint)(8);}
 while ((0) != 0);}}
 while ((0) != 0);strm.adler = (int)(state->check = (int)((((hold) >> 24) & 255) + (((hold) >> 8) & 65280) + (((hold) & 65280) << 8) + (((hold) & 255) << 24)));do {
hold = (int)(0);bits = (uint)(0);}
 while ((0) != 0);state->mode = (inflate_mode)(DICT);case DICT:if ((state->havedict) == (0)) {
do {
strm.next_out = put;strm.avail_out = (uint)(left);strm.next_in = next;strm.avail_in = (uint)(have);state->hold = (int)(hold);state->bits = (uint)(bits);}
 while ((0) != 0);return (int)(2);}
strm.adler = (int)(state->check = (int)(adler32((int)(0L), null, (uint)(0))));state->mode = (inflate_mode)(TYPE);case TYPE:if (((flush) == (5)) || ((flush) == (6))) goto inf_leave;case TYPEDO:if ((state->last) != 0) {
do {
hold >>= bits & 7;bits -= (uint)(bits & 7);}
 while ((0) != 0);state->mode = (inflate_mode)(CHECK);break;}
do {
while ((bits) < ((uint)(3))) {do {
if ((have) == (0)) goto inf_leave;have--;hold += (int)((int)(*next++) << bits);bits += (uint)(8);}
 while ((0) != 0);}}
 while ((0) != 0);state->last = (int)((uint)(hold) & ((1U << (1)) - 1));do {
hold >>= (1);bits -= ((uint)(1));}
 while ((0) != 0);switch (((uint)(hold) & ((1U << (2)) - 1))){
case 0:;state->mode = (inflate_mode)(STORED);break;case 1:fixedtables(state);state->mode = (inflate_mode)(LEN_);if ((flush) == (6)) {
do {
hold >>= (2);bits -= ((uint)(2));}
 while ((0) != 0);goto inf_leave;}
break;case 2:;state->mode = (inflate_mode)(TABLE);break;case 3:strm.msg = "invalid block type";state->mode = (inflate_mode)(BAD);}
do {
hold >>= (2);bits -= ((uint)(2));}
 while ((0) != 0);break;case STORED:do {
hold >>= bits & 7;bits -= (uint)(bits & 7);}
 while ((0) != 0);do {
while ((bits) < ((uint)(32))) {do {
if ((have) == (0)) goto inf_leave;have--;hold += (int)((int)(*next++) << bits);bits += (uint)(8);}
 while ((0) != 0);}}
 while ((0) != 0);if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
strm.msg = "invalid stored block lengths";state->mode = (inflate_mode)(BAD);break;}
state->length = (uint)((uint)(hold) & 0xffff);do {
hold = (int)(0);bits = (uint)(0);}
 while ((0) != 0);state->mode = (inflate_mode)(COPY_);if ((flush) == (6)) goto inf_leave;case COPY_:state->mode = (inflate_mode)(COPY);case COPY:copy = (uint)(state->length);if ((copy) != 0) {
if ((copy) > (have)) copy = (uint)(have);if ((copy) > (left)) copy = (uint)(left);if ((copy) == (0)) goto inf_leave;memcpy(put, next, (ulong)(copy));have -= (uint)(copy);next += copy;left -= (uint)(copy);put += copy;state->length -= (uint)(copy);break;}
state->mode = (inflate_mode)(TYPE);break;case TABLE:do {
while ((bits) < ((uint)(14))) {do {
if ((have) == (0)) goto inf_leave;have--;hold += (int)((int)(*next++) << bits);bits += (uint)(8);}
 while ((0) != 0);}}
 while ((0) != 0);state->nlen = (uint)(((uint)(hold) & ((1U << (5)) - 1)) + 257);do {
hold >>= (5);bits -= ((uint)(5));}
 while ((0) != 0);state->ndist = (uint)(((uint)(hold) & ((1U << (5)) - 1)) + 1);do {
hold >>= (5);bits -= ((uint)(5));}
 while ((0) != 0);state->ncode = (uint)(((uint)(hold) & ((1U << (4)) - 1)) + 4);do {
hold >>= (4);bits -= ((uint)(4));}
 while ((0) != 0);if (((state->nlen) > (286)) || ((state->ndist) > (30))) {
strm.msg = "too many length or distance symbols";state->mode = (inflate_mode)(BAD);break;}
state->have = (uint)(0);state->mode = (inflate_mode)(LENLENS);case LENLENS:while ((state->have) < (state->ncode)) {
do {
while ((bits) < ((uint)(3))) {do {
if ((have) == (0)) goto inf_leave;have--;hold += (int)((int)(*next++) << bits);bits += (uint)(8);}
 while ((0) != 0);}}
 while ((0) != 0);state->lens[order[state->have++]] = ((ushort)((uint)(hold) & ((1U << (3)) - 1)));do {
hold >>= (3);bits -= ((uint)(3));}
 while ((0) != 0);}while ((state->have) < (19)) {state->lens[order[state->have++]] = (ushort)(0);}state->next = state->codes;state->lencode = (state->next);state->lenbits = (uint)(7);ret = (int)(inflate_table((codetype)(CODES), state->lens, (uint)(19), &(state->next), &(state->lenbits), state->work));if ((ret) != 0) {
strm.msg = "invalid code lengths set";state->mode = (inflate_mode)(BAD);break;}
state->have = (uint)(0);state->mode = (inflate_mode)(CODELENS);case CODELENS:while ((state->have) < (state->nlen + state->ndist)) {
for (; ; ) {
here = (code)(state->lencode[((uint)(hold) & ((1U << (state->lenbits)) - 1))]);if ((uint)(here.bits) <= bits) break;do {
if ((have) == (0)) goto inf_leave;have--;hold += (int)((int)(*next++) << bits);bits += (uint)(8);}
 while ((0) != 0);}if ((here.val) < (16)) {
do {
hold >>= (here.bits);bits -= ((uint)(here.bits));}
 while ((0) != 0);state->lens[state->have++] = (ushort)(here.val);}
 else {
if ((here.val) == (16)) {
do {
while ((bits) < ((uint)(here.bits + 2))) {do {
if ((have) == (0)) goto inf_leave;have--;hold += (int)((int)(*next++) << bits);bits += (uint)(8);}
 while ((0) != 0);}}
 while ((0) != 0);do {
hold >>= (here.bits);bits -= ((uint)(here.bits));}
 while ((0) != 0);if ((state->have) == (0)) {
strm.msg = "invalid bit length repeat";state->mode = (inflate_mode)(BAD);break;}
len = (uint)(state->lens[state->have - 1]);copy = (uint)(3 + ((uint)(hold) & ((1U << (2)) - 1)));do {
hold >>= (2);bits -= ((uint)(2));}
 while ((0) != 0);}
 else if ((here.val) == (17)) {
do {
while ((bits) < ((uint)(here.bits + 3))) {do {
if ((have) == (0)) goto inf_leave;have--;hold += (int)((int)(*next++) << bits);bits += (uint)(8);}
 while ((0) != 0);}}
 while ((0) != 0);do {
hold >>= (here.bits);bits -= ((uint)(here.bits));}
 while ((0) != 0);len = (uint)(0);copy = (uint)(3 + ((uint)(hold) & ((1U << (3)) - 1)));do {
hold >>= (3);bits -= ((uint)(3));}
 while ((0) != 0);}
 else {
do {
while ((bits) < ((uint)(here.bits + 7))) {do {
if ((have) == (0)) goto inf_leave;have--;hold += (int)((int)(*next++) << bits);bits += (uint)(8);}
 while ((0) != 0);}}
 while ((0) != 0);do {
hold >>= (here.bits);bits -= ((uint)(here.bits));}
 while ((0) != 0);len = (uint)(0);copy = (uint)(11 + ((uint)(hold) & ((1U << (7)) - 1)));do {
hold >>= (7);bits -= ((uint)(7));}
 while ((0) != 0);}
if ((state->have + copy) > (state->nlen + state->ndist)) {
strm.msg = "invalid bit length repeat";state->mode = (inflate_mode)(BAD);break;}
while ((copy--) != 0) {state->lens[state->have++] = ((ushort)(len));}}
}if ((state->mode) == (BAD)) break;if ((state->lens[256]) == (0)) {
strm.msg = "invalid code -- missing end-of-block";state->mode = (inflate_mode)(BAD);break;}
state->next = state->codes;state->lencode = (state->next);state->lenbits = (uint)(9);ret = (int)(inflate_table((codetype)(LENS), state->lens, (uint)(state->nlen), &(state->next), &(state->lenbits), state->work));if ((ret) != 0) {
strm.msg = "invalid literal/lengths set";state->mode = (inflate_mode)(BAD);break;}
state->distcode = (state->next);state->distbits = (uint)(6);ret = (int)(inflate_table((codetype)(DISTS), state->lens + state->nlen, (uint)(state->ndist), &(state->next), &(state->distbits), state->work));if ((ret) != 0) {
strm.msg = "invalid distances set";state->mode = (inflate_mode)(BAD);break;}
state->mode = (inflate_mode)(LEN_);if ((flush) == (6)) goto inf_leave;case LEN_:state->mode = (inflate_mode)(LEN);case LEN:if (((have) >= (6)) && ((left) >= (258))) {
do {
strm.next_out = put;strm.avail_out = (uint)(left);strm.next_in = next;strm.avail_in = (uint)(have);state->hold = (int)(hold);state->bits = (uint)(bits);}
 while ((0) != 0);inflate_fast(strm, (uint)(_out_));do {
put = strm.next_out;left = (uint)(strm.avail_out);next = strm.next_in;have = (uint)(strm.avail_in);hold = (int)(state->hold);bits = (uint)(state->bits);}
 while ((0) != 0);if ((state->mode) == (TYPE)) state->back = (int)(-1);break;}
state->back = (int)(0);for (; ; ) {
here = (code)(state->lencode[((uint)(hold) & ((1U << (state->lenbits)) - 1))]);if ((uint)(here.bits) <= bits) break;do {
if ((have) == (0)) goto inf_leave;have--;hold += (int)((int)(*next++) << bits);bits += (uint)(8);}
 while ((0) != 0);}if (((here.op) != 0) && ((here.op & 0xf0) == (0))) {
last = (code)(here);for (; ; ) {
here = (code)(state->lencode[last.val + (((uint)(hold) & ((1U << (last.bits + last.op)) - 1)) >> last.bits)]);if ((uint)(last.bits + here.bits) <= bits) break;do {
if ((have) == (0)) goto inf_leave;have--;hold += (int)((int)(*next++) << bits);bits += (uint)(8);}
 while ((0) != 0);}do {
hold >>= (last.bits);bits -= ((uint)(last.bits));}
 while ((0) != 0);state->back += (int)(last.bits);}
do {
hold >>= (here.bits);bits -= ((uint)(here.bits));}
 while ((0) != 0);state->back += (int)(here.bits);state->length = ((uint)(here.val));if (((int)(here.op)) == (0)) {
state->mode = (inflate_mode)(LIT);break;}
if ((here.op & 32) != 0) {
state->back = (int)(-1);state->mode = (inflate_mode)(TYPE);break;}
if ((here.op & 64) != 0) {
strm.msg = "invalid literal/length code";state->mode = (inflate_mode)(BAD);break;}
state->extra = (uint)((uint)(here.op) & 15);state->mode = (inflate_mode)(LENEXT);case LENEXT:if ((state->extra) != 0) {
do {
while ((bits) < (state->extra)) {do {
if ((have) == (0)) goto inf_leave;have--;hold += (int)((int)(*next++) << bits);bits += (uint)(8);}
 while ((0) != 0);}}
 while ((0) != 0);state->length += (uint)((uint)(hold) & ((1U << (state->extra)) - 1));do {
hold >>= (state->extra);bits -= (uint)(state->extra);}
 while ((0) != 0);state->back += (int)(state->extra);}
state->was = (uint)(state->length);state->mode = (inflate_mode)(DIST);case DIST:for (; ; ) {
here = (code)(state->distcode[((uint)(hold) & ((1U << (state->distbits)) - 1))]);if ((uint)(here.bits) <= bits) break;do {
if ((have) == (0)) goto inf_leave;have--;hold += (int)((int)(*next++) << bits);bits += (uint)(8);}
 while ((0) != 0);}if ((here.op & 0xf0) == (0)) {
last = (code)(here);for (; ; ) {
here = (code)(state->distcode[last.val + (((uint)(hold) & ((1U << (last.bits + last.op)) - 1)) >> last.bits)]);if ((uint)(last.bits + here.bits) <= bits) break;do {
if ((have) == (0)) goto inf_leave;have--;hold += (int)((int)(*next++) << bits);bits += (uint)(8);}
 while ((0) != 0);}do {
hold >>= (last.bits);bits -= ((uint)(last.bits));}
 while ((0) != 0);state->back += (int)(last.bits);}
do {
hold >>= (here.bits);bits -= ((uint)(here.bits));}
 while ((0) != 0);state->back += (int)(here.bits);if ((here.op & 64) != 0) {
strm.msg = "invalid distance code";state->mode = (inflate_mode)(BAD);break;}
state->offset = ((uint)(here.val));state->extra = (uint)((uint)(here.op) & 15);state->mode = (inflate_mode)(DISTEXT);case DISTEXT:if ((state->extra) != 0) {
do {
while ((bits) < (state->extra)) {do {
if ((have) == (0)) goto inf_leave;have--;hold += (int)((int)(*next++) << bits);bits += (uint)(8);}
 while ((0) != 0);}}
 while ((0) != 0);state->offset += (uint)((uint)(hold) & ((1U << (state->extra)) - 1));do {
hold >>= (state->extra);bits -= (uint)(state->extra);}
 while ((0) != 0);state->back += (int)(state->extra);}
state->mode = (inflate_mode)(MATCH);case MATCH:if ((left) == (0)) goto inf_leave;copy = (uint)(_out_ - left);if ((state->offset) > (copy)) {
copy = (uint)(state->offset - copy);if ((copy) > (state->whave)) {
if ((state->sane) != 0) {
strm.msg = "invalid distance too far back";state->mode = (inflate_mode)(BAD);break;}
}
if ((copy) > (state->wnext)) {
copy -= (uint)(state->wnext);from = state->window + (state->wsize - copy);}
 else from = state->window + (state->wnext - copy);if ((copy) > (state->length)) copy = (uint)(state->length);}
 else {
from = put - state->offset;copy = (uint)(state->length);}
if ((copy) > (left)) copy = (uint)(left);left -= (uint)(copy);state->length -= (uint)(copy);do {
*put++ = (byte)(*from++);}
 while ((--copy) != 0);if ((state->length) == (0)) state->mode = (inflate_mode)(LEN);break;case LIT:if ((left) == (0)) goto inf_leave;*put++ = ((byte)(state->length));left--;state->mode = (inflate_mode)(LEN);break;case CHECK:if ((state->wrap) != 0) {
do {
while ((bits) < ((uint)(32))) {do {
if ((have) == (0)) goto inf_leave;have--;hold += (int)((int)(*next++) << bits);bits += (uint)(8);}
 while ((0) != 0);}}
 while ((0) != 0);_out_ -= (uint)(left);strm.total_out += (int)(_out_);state->total += (int)(_out_);if (((state->wrap & 4)!= 0) && ((_out_) != 0)) strm.adler = (int)(state->check = (int)((state->flags) != 0?crc32((int)(state->check), put - _out_, (uint)(_out_)):adler32((int)(state->check), put - _out_, (uint)(_out_))));_out_ = (uint)(left);if (((state->wrap & 4)!= 0) && (((state->flags) != 0?hold:((((hold) >> 24) & 255) + (((hold) >> 8) & 65280) + (((hold) & 65280) << 8) + (((hold) & 255) << 24))) != state->check)) {
strm.msg = "incorrect data check";state->mode = (inflate_mode)(BAD);break;}
do {
hold = (int)(0);bits = (uint)(0);}
 while ((0) != 0);}
state->mode = (inflate_mode)(LENGTH);case LENGTH:if (((state->wrap) != 0) && ((state->flags) != 0)) {
do {
while ((bits) < ((uint)(32))) {do {
if ((have) == (0)) goto inf_leave;have--;hold += (int)((int)(*next++) << bits);bits += (uint)(8);}
 while ((0) != 0);}}
 while ((0) != 0);if (hold != (state->total & 0xffffffffUL)) {
strm.msg = "incorrect length check";state->mode = (inflate_mode)(BAD);break;}
do {
hold = (int)(0);bits = (uint)(0);}
 while ((0) != 0);}
state->mode = (inflate_mode)(DONE);case DONE:ret = (int)(1);goto inf_leave;case BAD:ret = (int)(-3);goto inf_leave;case MEM:return (int)(-4);case SYNC:default: return (int)(-2);}}
			inf_leave:;
do {
strm.next_out = put;strm.avail_out = (uint)(left);strm.next_in = next;strm.avail_in = (uint)(have);state->hold = (int)(hold);state->bits = (uint)(bits);}
 while ((0) != 0);
			if (((state->wsize) != 0) || (((_out_ != strm.avail_out) && ((state->mode) < (BAD))) && (((state->mode) < (CHECK)) || (flush != 4)))) if ((updatewindow(strm, strm.next_out, (uint)(_out_ - strm.avail_out))) != 0) {
state->mode = (inflate_mode)(MEM);return (int)(-4);}

			_in_ -= (uint)(strm.avail_in);
			_out_ -= (uint)(strm.avail_out);
			strm.total_in += (int)(_in_);
			strm.total_out += (int)(_out_);
			state->total += (int)(_out_);
			if (((state->wrap & 4)!= 0) && ((_out_) != 0)) strm.adler = (int)(state->check = (int)((state->flags) != 0?crc32((int)(state->check), strm.next_out - _out_, (uint)(_out_)):adler32((int)(state->check), strm.next_out - _out_, (uint)(_out_))));
			strm.data_type = (int)((int)(state->bits) + ((state->last) != 0?64:0) + ((state->mode) == (TYPE)?128:0) + (((state->mode) == (LEN_)) || ((state->mode) == (COPY_))?256:0));
			if (((((_in_) == (0)) && ((_out_) == (0))) || ((flush) == (4))) && ((ret) == (0))) ret = (int)(-5);
			return (int)(ret);
		}

		public static int inflateEnd(z_stream_s strm)
		{
			inflate_state state;
			if ((inflateStateCheck(strm)) != 0) return (int)(-2);
			state = (inflate_state)(strm.state);
			if (state->window != null) strm.zfree(strm.opaque, (void *)(state->window));
			strm.zfree(strm.opaque, (void *)(strm.state));
			strm.state = null;
			return (int)(0);
		}

		public static int inflateGetDictionary(z_stream_s strm, byte* dictionary, uint* dictLength)
		{
			inflate_state state;
			if ((inflateStateCheck(strm)) != 0) return (int)(-2);
			state = (inflate_state)(strm.state);
			if (((state->whave) != 0) && (dictionary != null)) {
memcpy(dictionary, state->window + state->wnext, (ulong)(state->whave - state->wnext));memcpy(dictionary + state->whave - state->wnext, state->window, (ulong)(state->wnext));}

			if (dictLength != null) *dictLength = (uint)(state->whave);
			return (int)(0);
		}

		public static int inflateSetDictionary(z_stream_s strm, byte* dictionary, uint dictLength)
		{
			inflate_state state;
			int dictid = 0;
			int ret = 0;
			if ((inflateStateCheck(strm)) != 0) return (int)(-2);
			state = (inflate_state)(strm.state);
			if ((state->wrap != 0) && (state->mode != DICT)) return (int)(-2);
			if ((state->mode) == (DICT)) {
dictid = (int)(adler32((int)(0L), null, (uint)(0)));dictid = (int)(adler32((int)(dictid), dictionary, (uint)(dictLength)));if (dictid != state->check) return (int)(-3);}

			ret = (int)(updatewindow(strm, dictionary + dictLength, (uint)(dictLength)));
			if ((ret) != 0) {
state->mode = (inflate_mode)(MEM);return (int)(-4);}

			state->havedict = (int)(1);
			return (int)(0);
		}

		public static int inflateGetHeader(z_stream_s strm, gz_header_s* head)
		{
			inflate_state state;
			if ((inflateStateCheck(strm)) != 0) return (int)(-2);
			state = (inflate_state)(strm.state);
			if ((state->wrap & 2) == (0)) return (int)(-2);
			state->head = head;
			head->done = (int)(0);
			return (int)(0);
		}

		public static uint syncsearch(uint* have, byte* buf, uint len)
		{
			uint got = 0;
			uint next = 0;
			got = (uint)(*have);
			next = (uint)(0);
			while (((next) < (len)) && ((got) < (4))) {
if (((int)(buf[next])) == ((got) < (2)?0:0xff)) got++; else if ((buf[next]) != 0) got = (uint)(0); else got = (uint)(4 - got);next++;}
			*have = (uint)(got);
			return (uint)(next);
		}

		public static int inflateSync(z_stream_s strm)
		{
			uint len = 0;
			int _in_ = 0;int _out_ = 0;
			byte* buf = stackalloc byte[4];
			inflate_state state;
			if ((inflateStateCheck(strm)) != 0) return (int)(-2);
			state = (inflate_state)(strm.state);
			if (((strm.avail_in) == (0)) && ((state->bits) < (8))) return (int)(-5);
			if (state->mode != SYNC) {
state->mode = (inflate_mode)(SYNC);state->hold <<= state->bits & 7;state->bits -= (uint)(state->bits & 7);len = (uint)(0);while ((state->bits) >= (8)) {
buf[len++] = ((byte)(state->hold));state->hold >>= 8;state->bits -= (uint)(8);}state->have = (uint)(0);syncsearch(&(state->have), buf, (uint)(len));}

			len = (uint)(syncsearch(&(state->have), strm.next_in, (uint)(strm.avail_in)));
			strm.avail_in -= (uint)(len);
			strm.next_in += len;
			strm.total_in += (int)(len);
			if (state->have != 4) return (int)(-3);
			_in_ = (int)(strm.total_in);
			_out_ = (int)(strm.total_out);
			inflateReset(strm);
			strm.total_in = (int)(_in_);
			strm.total_out = (int)(_out_);
			state->mode = (inflate_mode)(TYPE);
			return (int)(0);
		}

		public static int inflateSyncPoint(z_stream_s strm)
		{
			inflate_state state;
			if ((inflateStateCheck(strm)) != 0) return (int)(-2);
			state = (inflate_state)(strm.state);
			return (int)(((state->mode) == (STORED)) && ((state->bits) == (0))?1:0);
		}

		public static int inflateCopy(z_stream_s dest, z_stream_s source)
		{
			inflate_state state;
			inflate_state copy;
			byte* window;
			uint wsize = 0;
			if (((inflateStateCheck(source)) != 0) || ((dest) == (null))) return (int)(-2);
			state = (inflate_state)(source->state);
			copy = (inflate_state)(*((source)->zalloc)((source)->opaque, (uint)(1), (uint)(sizeof(inflate_state))));
			if ((copy) == (null)) return (int)(-4);
			window = null;
			if (state->window != null) {
window = (byte*)(*((source)->zalloc)((source)->opaque, (uint)(1U << state->wbits), (uint)(sizeof(unsignedchar))));if ((window) == (null)) {
*((source)->zfree)((source)->opaque, (void *)(copy));return (int)(-4);}
}

			memcpy((void *)(dest), (void *)(source), (ulong)(sizeof(z_stream_s)));
			memcpy((void *)(copy), (void *)(state), (ulong)(sizeof(inflate_state)));
			copy->strm = dest;
			if (((state->lencode) >= (state->codes)) && (state->lencode <= state->codes + (852 + 592) - 1)) {
copy->lencode = copy->codes + (state->lencode - state->codes);copy->distcode = copy->codes + (state->distcode - state->codes);}

			copy->next = copy->codes + (state->next - state->codes);
			if (window != null) {
wsize = (uint)(1U << state->wbits);memcpy(window, state->window, (ulong)(wsize));}

			copy->window = window;
			dest->state = (internal_state)(copy);
			return (int)(0);
		}

		public static int inflateUndermine(z_stream_s strm, int subvert)
		{
			inflate_state state;
			if ((inflateStateCheck(strm)) != 0) return (int)(-2);
			state = (inflate_state)(strm.state);
			(void)(subvert);
			state->sane = (int)(1);
			return (int)(-3);
		}

		public static int inflateValidate(z_stream_s strm, int check)
		{
			inflate_state state;
			if ((inflateStateCheck(strm)) != 0) return (int)(-2);
			state = (inflate_state)(strm.state);
			if ((check) != 0) state->wrap |= (int)(4); else state->wrap &= (int)(~4);
			return (int)(0);
		}

		public static int inflateMark(z_stream_s strm)
		{
			inflate_state state;
			if ((inflateStateCheck(strm)) != 0) return (int)(-(1L << 16));
			state = (inflate_state)(strm.state);
			return (int)(((state->back) << 16) + ((state->mode) == (COPY)?state->length:((state->mode) == (MATCH)?state->was - state->length:0)));
		}

		public static int inflateCodesUsed(z_stream_s strm)
		{
			inflate_state state;
			if ((inflateStateCheck(strm)) != 0) return (int)(-1);
			state = (inflate_state)(strm.state);
			return (int)(state->next - state->codes);
		}

}
}