using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Sichem;

namespace Generator
{
    public enum GroupType
    {
        Constants,
        Enums,
        Globals,
        Structs,
        Methods,
    }

    class Program
    {
        static void Main(string[] args)
        {
            const string dir = @"..\..\..\ZlibSharp\";

            var sourceEntries = new string[][]
            {
                new [] { "adler32.c",  "Adler32", },
                new [] { "compress.c", "Compress" },
                new [] { "crc32.c",    "Crc32",   },
                new [] { "deflate.c",  "Deflate", },
                new [] { "gzclose.c",  "GZClose", },
                new [] { "gzlib.c",    "GZLib",   },
                new [] { "gzread.c",   "GZRead",  },
                new [] { "gzwrite.c",  "GZWrite", },
                new [] { "infback.c",  "InfBack", },
                new [] { "inffast.c",  "InfFast", },
                new [] { "inflate.c",  "InfLate", },
                new [] { "inftrees.c", "InfTrees" },
                new [] { "trees.c",    "Trees",   },
                new [] { "uncompr.c",  "Uncompress", },
                new [] { "zutil.c",    "ZUtil" }
            };

            Directory.CreateDirectory(dir);

            var cp = new ClangParser();
            var sb = new StringBuilder();

            for (int i = 0; i < sourceEntries.Length; i++)
            {
                Console.WriteLine();
                Console.WriteLine();

                var parameters = new ConversionParameters
                {
                    InputPath = Path.GetFullPath(@"..\..\..\zlib\" + sourceEntries[i][0]),
                    Class = sourceEntries[i][1],
                    Namespace = "ZlibSharp",
                    Defines = new string[] { },
                };

                Logger.Info($"Reading {parameters.InputPath}...");

                ConversionResult result;
                //try
                {
                    result = cp.Process(parameters);
                }
                //catch (Exception ex)
                //{
                //    Console.WriteLine(ex);
                //    continue;
                //}

                // Post processing
                Logger.Info($"Writing {parameters.InputPath}...");

                var builder = new StringBuilder();
                Write(GroupType.Constants, result.Constants, builder);
                Write(GroupType.Globals, result.GlobalVariables, builder);
                Write(GroupType.Enums, result.Enums, builder);
                Write(GroupType.Structs, result.Structs, builder);
                Write(GroupType.Methods, result.Methods, builder);

                var data = builder; // PostProcess(pair.Value);

                sb.Clear();
                sb.AppendLine(string.Format("// Generated by Sichem at {0}", DateTime.Now));
                sb.AppendLine();

                sb.AppendLine("using System;");
                sb.AppendLine("using System.Runtime.InteropServices;");
                sb.AppendLine("using static CRuntime;");

                sb.AppendLine();

                sb.Append($"namespace {parameters.Namespace}\n{{\n\t");
                sb.AppendLine($"unsafe class {parameters.Class}\n\t{{");

                data.Insert(0, sb);
                data.Append("}\n}");

                string path = dir + parameters.Class + ".cs";

                if (data.Length > 0)
                {
                    File.WriteAllText(path, data.ToString());
                }
                else
                {
                    Console.WriteLine("Empy " + path);
                }
            }

            Console.ReadKey();
        }

        private static void Write(
            GroupType type, Dictionary<string, StringBuilder> input, StringBuilder output)
        {
            foreach (var pair in input)
            {
                switch (type)
                {
                    case GroupType.Methods:
                        if (pair.Key == "deflateCopy")
                            continue;
                        break;
                }

                output.Append(pair.Value);
            }

            switch (type)
            {
                case GroupType.Structs:
                    output.Replace("public sbyte* msg;", "public string msg;");
                    break;
            }

            output.Replace("unsigned int (void*, unsigned char **)*", "inflate_func");
            output.Replace("void *(void *, unsigned int, unsigned int)*", "zalloc_delegate");
            output.Replace("void (void *, void *)*", "zfree_delegate");
            output.Replace("block_state (internal_state *, int)*", "deflate_func");

            output.Replace("(block_state)((0)?finish_started:need_more)", "(block_state)(need_more)");
            output.Replace("(block_state)((1)?finish_started:need_more)", "(block_state)(finished_started)");

            output.Replace("public struct z_stream_s", "public class z_stream_s");
            output.Replace("public struct internal_state", "public class internal_state");
            output.Replace("public struct inflate_state", "public class inflate_state");

            output.Replace("internal_state*", "internal_state");
            output.Replace("inflate_state*", "inflate_state");
            output.Replace("z_stream_s*", "z_stream_s");

            output.Replace("*((strm)->", "(strm.");
            output.Replace("(strm)->", "strm.");
            output.Replace("strm->", "strm.");

            output.Replace("strm.state->", "strm.state.");
            output.Replace("(s)->", "s.");
            output.Replace("s->", "s.");

            output.Replace("(strm.zalloc)", "strm.zalloc");
            output.Replace("(strm.zfree)", "strm.zfree");
        }
    }
}
